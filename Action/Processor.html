<!DOCTYPE html><html lang="en"><head><title>Action/Processor</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="Action/Processor"><meta name="groc-project-path" content="src/Action/Processor.coffee"><meta name="groc-github-url" content="https://github.com/sjorek/goatee-js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sjorek/goatee-js/blob/master/src/Action/Processor.coffee">src/Action/Processor.coffee</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>© Copyright 2013 Stephan Jorek <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;:&#x73;&#x74;&#101;&#x70;&#104;&#97;n&#x2e;&#x6a;&#111;&#114;&#101;&#x6b;&#x40;&#x67;&#109;&#x61;&#x69;&#108;.c&#111;&#109;">&#x73;&#x74;&#101;&#x70;&#104;&#97;n&#x2e;&#x6a;&#111;&#114;&#101;&#x6b;&#x40;&#x67;&#109;&#x61;&#x69;&#108;.c&#111;&#109;</a> <br />
© Copyright 2006 Google Inc. <a href="http://www.google.com">http://www.google.com</a></p>

<p>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>

<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>

<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h1 id="gaotee-evaluation">Gaotee Evaluation</h1>

<blockquote>
  <h2 id="overview">Overview</h2>
  
  <p>The processing instructions that define the results of Processor for a
  template are encoded as attributes in template HTML elements.  There are
  <del>eight such</del> special attributes: <em>jsselect</em>, <em>jsdisplay</em>, <em>jsskip</em>,
  <em>jscontent</em>, <em>jsvars</em>, <em>jsvalues</em>, <em>jseval</em>, and <em>transclude</em>.  Before you
  dive into the details of individual instructions, however, you should know a
  little bit about the namespace within which these instructions are processed.</p>
  
  <h2 id="processing-environment">Processing Environment</h2>
  
  <p>With the single exception of the <em>transclude</em> instruction, the values of all
  Template attributes will contain <del>javascript</del> expressions.  These
  will be evaluated in an environment that includes bindings from a variety of
  sources, and names defined by any of these sources can be referenced in
  attribute expressions as if they were variables:</p>
  
  <ul>
  <li><em>Context</em> data: All the properties of the <em>Context</em>'s data object are included
  in the processing environment.</li>
  <li><p>Explicitly declared variables: The <code>setVariable(name, value);</code> method of
  <em>Context</em> creates a new variable with the <code>name</code> in the processing
  environment if no such variable exists, assigning it the <code>value</code>. If the
  variable already exists, it will be reassigned the <code>value</code>.  Variables can
  also be created and assigned with the <em>jsvalues</em> instruction (see below).</p>
  
  <p>Note that variables defined in either of these ways are distinct from the
  <em>Context</em> data object. Calling <code>setVariable</code> will not alter the data wrapped
  by the <em>Context</em> instance.  This fact can have important consequences when
  template processing is traversing the hierarchy of the data object (through
  the use of the <em>jsselect</em> instruction, for example -- see below): no matter
  what portion of the data hierarchy has been selected for processing, variables
  created with <code>setVariable</code> will always be available for use in template
  processing instructions.</p></li>
  <li><p>Special variables: Jst also defines three special variables that can be used
  in processing instruction attributes:</p>
  
  <ul><li><code>this</code>: The keyword <code>this</code> in <em>Template</em> attribute expressions will
  evaluate to the element on which the attribute is defined.  In this
  respect <em>Template</em> attributes mirror event handler attributes like
  <code>onclick</code>.</li>
  <li><code>$index</code>: Array-valued data can result in a duplicate template node being
  created for each array element (see <em>jsselect</em>, below).  In this case the
  processing environment for each of those nodes includes <code>$index</code> variable,
  which will contain the array index of the element associated with the node.</li>
  <li><code>$this</code>: refers to the <em>Context</em> data object used in processing the current
  node.  So in the above example (TODO which example?!?) we could substitute
  <code>$this.end</code> for <code>end</code> without changing the meaning of the <em>jscontent</em>
  expression.  This may not seem like a very useful thing to do in this
  case, but there are other cases in which <code>$this</code> is necessary.  If the
  <em>Context</em> contains a value such as a string or a number rather than an
  object with named properties, there is no way to retrieve the value using
  object-property notation, and so we need <code>$this</code> to access the value.</li></ul></li>
  </ul>
  
  <p>So if you have the template</p>

<pre><code> &lt;div id="witha"&gt;
   &lt;div id="Hey"
        jscontent="this.parentNode.id +
                   this.id +
                   dataProperty +
                   $this.dataProperty +
                   declaredVar"
   &gt;&lt;!-- empty content to be replaced --&gt;&lt;/div&gt;
 &lt;/div&gt;
</code></pre>
  
  <p>and you process it with the statements</p>

<pre><code> var mydata = {dataProperty: 'Nonny'};
 var context = new JsEvalContext(mydata);
 context.setVariable('declaredVar', 'Ho');
 var template = document.getElementById('witha');
 jstProcess(context, template);
</code></pre>
  
  <p>then the document will display the string <code>withaHeyNonnyNonnyHo</code>. The values
  of <code>id</code> and <code>parentNode.id</code> are available as properties of the current node
  (accessible through the keyword <code>this</code>), the value of <code>dataProperty</code> is
  available (via both a naked reference and the special variable <code>$this</code>)
  because it is defined in the <em>Context</em>'s data object, and the value of
  <code>declaredVar</code> is available because it is defined in the <em>Context</em>'s variables.</p>
  
  <p>In the discussion of specific instruction attributes below, the phrase
  <em>“current node”</em> refers to the DOM element on which the attribute is defined.</p>
</blockquote>

<p>Goatee action attributes and event action names have been choosen
carefully in order to avoid naming collision with existing dom attributes,
events and properties.</p>

<p>Within a single element the actions are evaluated in the following order:</p>

<h2 id="outer-actions">Outer Actions</h2>

<p>Outer actions operate with and on tag and context, without touching any tag-
attributes. They implement aspects like automation, recursion or multiplicity.</p>

<ul>
<li><p><strong>process</strong> : This action initiates the processing automatically, after
the dom is ready. The algorithm uses the given <em>process</em>-data
as Context.  Additionally if “<a href="http://jquery.com">jQuery</a>” is
available and the given data is a string, <em>process</em> may be
either an global javascript variable reference, or if that fails
an url to an external json-file.  Changes to the process value,
will stop any process processing the same tag and start
re-processing.  The process will skip all nested tags which
itself contain a <em>process</em>-Attribute, hence any of those tags
will be processed automatically in the order of their
appearance.</p></li>
<li><p><strong>match</strong>   : If “<a href="http://jsonselect.org">json:select</a>” is available <em>match</em>
value is used as css3-like query onto the current context.
Therefore the context must be suiteable as 2nd argument of
<code>JSONSelect.match(…)</code>.</p></li>
<li><p><strong>render</strong>  : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">transclude</a>”.
If a <em>render</em> action is present no further actions are
processed.  Additionally if either “<a href="http://jquery.com">jQuery</a>”,
“<a href="http://matthewmueller.github.io/cheerio/">cheerio</a>”, or
“<a href="http://sizzlejs.com">Sizzle</a>” is available, <em>render</em> may be an
internal template-reference, like in:
<code>(cheerio||jQuery||Sizzle)( 'source #id .selector', this );</code>
or in the case of <em>jQuery</em> an external reference, like in:
<code>jQuery(this).load( 'http://source.url #element-id' );</code>


<blockquote>
  <p></p></p>
</blockquote>

<blockquote>
  <p>As <em>jsselect</em> does, the <em>transclude</em> instruction expands the
  structure of a template.  It does so by copying a structure
  from some other element in the document.  The value of the
  <em>transclude</em> attribute is interpreted as an element id literal
  rather than as a <del>javascript</del> expression. (This
  difference, by the way, is the reason for the absence of a
  “js” in its name.)</p>
  
  <p>If an element with the given id exists in the document, it is
  cloned and <strong>the clone replaces</strong> the node with the <em>transclude</em>
  attribute.  Template processing continues on the new element.
  If no element with the given id exists, the node with the
  <em>transclude</em> attribute is removed.  No further processing
  instruction attributes will be evaluated on a node if it has
  a <em>transclude</em> attribute.</p>
  
  <p>The <em>transclude</em> attribute allows for recursion, because a
  template can be transcluded into itself.  This feature can be
  handy when you want to display hierarchically structured data.
  If you have a hierarchically structured table of contents, for
  example, recursive <em>transclude</em> statements allow you represent
  the arbitrarily complex hierarchy with a simple template:</p>

<pre><code>&lt;script&gt;
   …
   // Hierarchical data:
   var tplData = {
     title: "JsTemplate",
     items: [ {
       title: "Using JsTemplate",
       items: [ {
         title: "The JsTemplate Module"
       }, {
         title: "Javascript Data"
       }, {
         title: "Template HTML"
       }, {
         title: "Processing Templates with Javascript Statements"
       } ]
     }, {
       title: "Template Processing Instructions",
       items: [ {
         title: "Processing Environment"
       }, {
         title: "Instruction Attributes",
         items: [ {
           title: "jscontent"
         }, {
           title: "jsselect"
         }, {
           title: "jsdisplay"
         }, {
           title: "transclude"
         }, {
           title: "jsvalues"
         }, {
           title: "jsskip"
         }, {
           title: "jseval"
         } ]
       } ]
     } ]
   };
   …
 &lt;/script&gt;
 &lt;div id="tpl"&gt;
   &lt;span jscontent="title"&gt;Outline heading&lt;/span&gt;
   &lt;ul jsdisplay="items.length"&gt;
     &lt;li jsselect="items"&gt;
       &lt;div transclude="tpl"&gt;&lt;!-- recursive tranclusion --&gt;&lt;/div&gt;
     &lt;/li&gt;
   &lt;/ul&gt;
 &lt;/div&gt;
</code></pre>
  
  <p>The recursion in this example terminates because eventually
  it reaches data objects that have no <code>items</code> property.  When
  the <em>jsselect</em> asks for <code>items</code> on one of these leaves, it
  evaluates to <code>null</code> and no further processing will be
  performed on that node.  Note also that when the node with a
  <em>transclude</em> attribute is replaced with the transcluded node
  in this example, the replacement node will not have a
  <em>transclude</em> attribute.</p>
  
  <p><em>“How to use JsTemplate”</em> described the use of the
  <code>jstGetTemplate</code> function to process a copy of a template
  rather than the original template.  Templates with recursive
  transcludes must be cloned in this way before processing.
  Because of the internal details of Jst processing, a template
  that contains a recursive reference to itself may be processed
  incorrectly if the original template is processed directly.
  The following (incomplete) javascript code will perform the
  required duplication for the above template:</p>

<pre><code>&lt;script&gt;
  var PEG_NAME = 'peg';
  var TEMPLATE_NAME = 'tpl';
  // Called by the body onload handler:
  function jsinit() {
    pegElement = domGetElementById(document, PEG_NAME);
    loadData(pegElement, TEMPLATE_NAME, tplData);
  }

  function loadData(peg, templateId, data) {
    // Get a copy of the template:
    var templateToProcess = jstGetTemplate(templateId);
    // Wrap our data in a context object:
    var processingContext = new JsEvalContext(data);
    // Process the template
    jstProcess(processingContext, templateToProcess);
    // Clear the element to which we'll attach the processed template:
    peg.innerHTML = '';
    // Attach the template:
    appendChild(peg, templateToProcess);
  }
&lt;/script&gt;
</code></pre>
</blockquote></li>
<li><p><strong>repeat</strong>  : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsselect</a>”.
If <em>repeat</em> is array-valued, remaining actions will be copied to
each new duplicate element created by the <em>repeat</em> and processed
when the further dom- traversal visits the new elements.


<blockquote>
  <p></p></p>
</blockquote>

<blockquote>
  <p>The primary function of JsTemplate is to create mappings
  between data structures and HTML representations of those data
  structures.  The <em>jsselect</em> attribute handles much of the work
  of defining this mapping by allowing you to associate a
  particular subtree of the data with a particular subtree of
  the template's DOM structure. When a template node with a
  <em>jsselect</em> attribute is processed, the value of the <em>jsselect</em>
  attribute is evaluated as a <del>javascript</del> expression
  in the current processing environment, as described above.
  If the result of this evaluation is not an array, the
  processor automatically creates a new <em>Context</em> object to wrap
  the result of the evaluation.  The processing environment for
  the current node now uses this new <em>Context</em> rather than the
  original <em>Context</em>.</p>
  
  <p>For example, imagine that you have the following data object
  (wrapped in a <em>Context</em> object constructed with
  <code>new Context(tplData);</code>):</p>

<pre><code>&lt;script&gt;
  …
  var tplData = {
    username:"Jane User",
    addresses:[ {
      location:"111 8th Av.",
      label:"NYC front door"
    }, {
      location:"76 9th Av.",
      label:"NYC back door"
    }, {
      location:"Mountain View",
      label:"Mothership"
    } ]
  };
  …
&lt;/script&gt;
</code></pre>
  
  <p>and you use this data in processing the template</p>

<pre><code>&lt;div id="tpl"&gt;
  &lt;span jsselect="username"
        jscontent="$this"
  &gt;&lt;!-- empty --&gt;&lt;/span&gt;'s Address Book
&lt;/div&gt;
</code></pre>
  
  <p>The <em>jsselect</em> attribute tells the processor to retrieve the
  username property of the data object, wrap this value
  (<em>“Jane User”</em>) in a new JsEvalContext, and use the new
  <em>Context</em> in processing the span element.  As a result,
  <code>$this</code> refers to <em>“Jane User”</em> in the context of the span,
  and the <em>jscontent</em> attribute evaluates to <code>"Jane User"</code>.</p>
  
  <p>Note that the <em>jsselect</em> has to be executed before the
  <em>jscontent</em> in order for this example to work.  In fact,
  <em>jsselect</em> is always evaluated before any other JsTemplate
  attributes (with the exception of <em>transclude</em>), and so the
  processing of all subsequent instructions for the same
  template element will take place in the new environment
  created by the jsselect (see <em>“Order of Evaluation”</em> below).</p>
  
  <p>What happens if you try to <em>jsselect</em> the array-valued
  addresses property of the data object?  If the result of
  evaluating a <em>jsselect</em> expression is an array, a duplicate
  of the current template node is created for each item in the
  array.  For each of these duplicate nodes a <code>new Context( … );</code>
  will be created to wrap the array item, and the processing
  environment for the duplicate node now uses this <em>Context</em>
  rather than the original.  In other words, <em>jsselect</em> operates
  as a sort of <code>foreach</code> statement in the case of arrays.  So
  you can expand your address book template to list addresses in
  your data object like so:</p>

<pre><code>&lt;div id="tpl"&gt;
  &lt;h1&gt;
    &lt;span jsselect="username"
          jscontent="$this"&gt;
      User de Fault
    &lt;/span&gt;'s Address Book
  &lt;/h1&gt;
  &lt;table cellpadding="5"&gt;
    &lt;tr&gt;
      &lt;th&gt;Location:&lt;/th&gt;
      &lt;th&gt;Label:&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr jsselect="addresses"&gt;
      &lt;td jscontent="location"&gt;&lt;!-- location --&gt;&lt;/td&gt;
      &lt;td jscontent="label"&gt;&lt;!-- label --&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
  
  <p>Processing this template with your <em>“Jane User”</em> address book
  data will produce a nice table with a row for each address.
  Since the execution of a <em>jsselect</em> instruction can change the
  number of children under a template node, we might worry that
  if we try to reprocess a template with new data the template
  will no longer have the structure we want.  JsTemplate manages
  this problem with a couple of tricks.  First, whenever a
  <em>jsselect</em> produces duplicate nodes as a result of an
  array-valued expression, the processor records an index for
  each node as an attribute of the element.  So if the duplicate
  nodes are reprocessed, the processor can tell that they
  started out as a single node and will reprocess them as if
  they are still the single node of the original template.
  Second, a template node is never entirely removed, even if a
  <em>jsselect</em> evaluates to <code>null</code>.  If it evaluates to <code>null</code> (or
  <code>undefined</code>), the current node will be hidden by setting
  <code>style="display:none"</code>, and no further processing will be
  performed on it.  But the node will still be present, and
  available for future reprocessing.</p>
</blockquote></li>
</ul>

<h2 id="inner-actions">Inner Actions</h2>

<p>Inner actions operate on tag element-attributes, -properties and -methods as
well as the context-data, -variables and -values.</p>

<ul>
<li><p><strong>appear</strong>  : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsdisplay</a>”.
The result determines if the node appears on page.  Therefore
the result is either booleanized and applied as css-display,
with <code>false</code> ~ <code>style="display: none"</code> and <code>true</code> ~
<code>style="display: block"</code>.  If the result matches a valid value
for css-display it is used directly in <code>display: …</code>.</p>

<blockquote>
  <p>The value of the <em>jsdisplay</em> attribute is evaluated as a
  <del>javascript</del> expression.  If the result is <code>false</code>,
  <code>0</code>, <code>""</code> or any other <del>javascript</del> value that is
  <code>true</code> when negated, the CSS display property of the current
  template node will be set to <em>“none”</em>, rendering it invisible
  <insert><em>without detaching it from the DOM</em><insert>, and no
  further processing will be done on this node or its children.
  This instruction is particularly useful for checking for empty
  content.  You might want to display an informative message if
  a user's address book is empty, for example, rather than just
  showing them an empty table.  The following template will
  accomplish this goal:</p>

<pre><code>&lt;div id="tpl"&gt;
  &lt;h1&gt;
    &lt;span jsselect="username"
          jscontent="$this"&gt;User de Fault&lt;/span&gt;'s Address Book
  &lt;/h1&gt;
  &lt;span jsdisplay="addresses.length==0"&gt;Address book is empty.&lt;/span&gt;
  &lt;table cellpadding="5" jsdisplay="addresses.length"&gt;
    &lt;tr&gt;
      &lt;th&gt;Location:&lt;/th&gt;
      &lt;th&gt;Label:&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr jsselect="addresses"&gt;
      &lt;td jscontent="location"&gt;&lt;!-- location --&gt;&lt;/td&gt;
      &lt;td jscontent="label"&gt;&lt;!-- label --&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
  
  <p>If the addresses array is empty, the user will see
  <em>“Address book is empty”</em>, but otherwise they will see the
  table of addresses as usual.</p>
</blockquote></li>
<li><p><strong>set</strong>     : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsvars</a>”.</p>

<blockquote>
  <p>This instruction is identical to <em>jsvalues</em>, except that all
  assignment targets are interpreted as variable names, whether
  or not they start with a dolar-sign (<em>“$”</em>) or a dot (<em>“.”</em>).
  That is, all assignment targets are interpreted as described
  in section 1 of the <em>jsvalues</em> section below.</p>
</blockquote></li>
<li><p><strong>alter</strong>   : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsvalues</a>”.</p>

<blockquote>
  <p>The <em>jsvalues</em> instruction provides a way of making
  assignments that alter the template processing environment.
  The template processor parses the value of the <em>jsvalues</em>
  attribute value as a semicolon-delimited list of name value
  pairs, with every name separated from its value by a colon.
  Every name represents a target for assignment.  Every value
  will be evaluated as a javascript expression and assigned to
  its associated target.  The nature of the target depends on
  the first character of the target name:</p>
  
  <ul><li>If the first character of the target name is "$", then the
  target name is interpreted as a reference to a variable in
  the current <code>JsEvalContext</code> processing environment.  This
  variable is created if it doesn't already exist, and
  assigned the result of evaluating its associated expression.
  It will then be available for subsequent template processing
  on this node and its descendants (including subsequent
  name-value pairs in the same <em>jsvalues</em> attribute). Note
  that the dollar sign is actually part of the variable name:
  if you create a variable with <code>jsvalues="$varname:varvalue"</code>,
  you must use <code>$varname</code> to retrieve the value.</li>
  <li>If the first character of the target name is ".", then the
  target name is interpreted as a reference to a javascript
  property of the current template node.  The property is
  created if it doesn't already exist, and is assigned the
  result of evaluating its associated expression. So the
  instruction <code>jsvalues=".id:'Joe';.style.fontSize:'30pt'"</code>
  would change the id of the current template node to "Joe"
  and change its font size to 30pt.</li>
  <li>If the first character of the target name is neither a dot
  nor a dollar sign, then the target name is interpreted as a
  reference to an XML attribute of the current template
  element.  In this case the instruction <code>jsvalues="name:value"</code>
  is equivalent to the javascript statement <code>this.setAttribute('name','value');</code>,
  where this refers to the current template node.  Just as in
  the case of a call to setAttribute, the value will be
  interpreted as a string (after javascript evaluation). So
  <code>jsvalues="sum:1+2"</code> is equivalent to <code>this.setAttribute('sum', '3');</code>.</li></ul>
  
  <p>The jsvalues instruction makes a handy bridge between the DOM
  and context data.  If you want a built-in event handler
  attribute like <code>onclick=" … "</code> to be able to access the
  currently selected portion of the <code>JsEvalContext</code> data, for
  example, you can use <em>jsvalues</em> to copy a reference to the
  data into an attribute of the current element, where it will
  be accessible in the <code>onclick=" … "</code> attribute via `this.
  The following example uses this approach to turn our outline
  into a collapsible outline:</p>

<pre><code>&lt;script&gt;
  // Function called by onclick to record state of
  // closedness and refresh the outline display
  function setClosed(jstdata, closedVal) {
    jstdata.closed = closedVal;
    loadData(PEG_ELEMENT, TEMPLATE_NAME, tplData);
  }
&lt;/script&gt;
&lt;div id="tpl"&gt;
  &lt;!-- Links to open and close outline sections: --&gt;
  &lt;a href="#"
     jsdisplay="closed"
     jsvalues=".jstdata:$this"
     onclick="setClosed(this.jstdata,0)"&gt;[Open]&lt;/a&gt;
  &lt;a href="#"
     jsdisplay="!closed &amp;&amp; items.length"
     jsvalues=".jstdata:$this"
     onclick="setClosed(this.jstdata,1)"&gt;[Close]&lt;/a&gt;
  &lt;span jscontent="title"&gt;Outline heading&lt;/span&gt;
  &lt;ul jsdisplay="items.length &amp;&amp; !closed"&gt;
    &lt;li jsselect="items"&gt;
      &lt;div transclude="tpl"&gt;
        &lt;!-- recursive tranclusion --&gt;
      &lt;/div&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</blockquote></li>
<li><p><strong>do</strong>      : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jseval</a>”.</p>

<blockquote>
  <p>The processor evaluates a jseval instruction as a javascript
  expression, or a series of javascript expressions separated by
  semicolons.  The jseval instruction thus allows you to invoke
  javascript functions during template processing, in the usual
  template processing environment, but without any of the
  predefined template processing effects of <em>jsselect</em>, <em>jsvalues</em>,
  <em>jsdisplay</em>, <em>jsskip</em>, or <em>jscontent</em>.  For example, with the
  addition of a jseval instruction to our outline title span,
  the processor can record a count of the total number of
  outline items with and without titles as it traverses the data
  hierarchy.</p>
  
  <p>The count information in this example is stored in the
  processing context with a call to setVariable, so that it
  will be available to template processing throughout the data
  hierarchy:</p>

<pre><code>var counter = { full: 0 };
processingContext.setVariable('$counter', counter);
</code></pre>
  
  <p>A jseval expression increments the count:</p>

<pre><code>&lt;span jscontent="title"
      jseval="title? $counter.full++: $counter.empty++"&gt;
  Outline heading
&lt;/span&gt;
</code></pre>
  
  <p>and then a separate template displays these counts at the
  bottom of the page:</p>

<pre><code>&lt;div id="titleCountTpl"&gt;
  &lt;p&gt;
    This outline has
    &lt;span jscontent="$counter.empty"&gt;0&lt;/span&gt;
    empty titles and
    &lt;span jscontent="$counter.full"&gt;0&lt;/span&gt;
    titles with content.
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
  
  <p>Note that when you close headings the counts change:
  <em>jsdisplay</em> is not only hiding the closed elements, but also
  aborting the processing of these elements, so that the
  <em>jseval</em> expressions on these elements are never evaluated.</p>
</blockquote></li>
<li><p><strong>skip</strong>    : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsskip</a>”.</p>

<blockquote>
  <p>The value of the <em>jsskip</em> attribute is evaluated as a
  javascript expression.  If the result is any javascript value
  that evaluates to true in a boolean context, then the
  processor will not process the subtree under the current node.
  This instruction is useful for improving the efficiency of an
  application (to avoid unnecessarily processing deep trees, for
  example).</p>
  
  <p>The effect of a jsskip that evaluates to true is very similar
  to the result of a jsdisplay that evaluates to false.  In both
  cases, no processing will be performed on the node's children.
  However, <em>jsskip</em> will not prevent the current node from being
  displayed.</p>
</blockquote></li>
<li><p><strong>markup</strong>  : This action is present if <code>(cheerio|jQuery)( … ).html( … );</code> is
available.  This is nearly the same action as the <em>text</em>-action
below, except it allows markup to be embedded.
<strong>Use it with absolute caution! You have been warned !</strong></p></li>
<li><p><strong>text</strong>    : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jscontent</a>”.
Uses <code>(cheerio|jQuery)( … ).text( … );</code> if available.  Otherwise
the given content will be assigned to <code>Node.innerHTML</code>.</p>

<blockquote>
  <p>This attribute is evaluated as a javascript expression in the
  current processing environment.  The string value of the
  result then becomes the text content of the current node.
  So the template:</p>

<pre><code>&lt;p id="tpl"&gt;
  Welcome &lt;span jscontent="$this"&gt;username&lt;/span&gt;
&lt;/p&gt;
</code></pre>
  
  <p>… when processed with the javascript statements:</p>

<pre><code>var tplData = "Joe User",
    input   = new JsEvalContext(tplData),
    output  = document.getElementById('tpl');
jstProcess(input, output);
</code></pre>
  
  <p>… will display <code>Welcome Joe User</code> in the browser.  Note the
  use of <code>$this</code> here: the <code>JsEvalContext</code> constructor is passed
  the string <code>"Joe User"</code>, and so this is the object to which
  <code>$this</code> refers.</p>
  
  <p>When the processor executes a <em>jscontent</em> instruction, a new
  text node object is created with the string value of the
  result as its nodeValue, and this new text node becomes the
  only child of the current node.  This implementation ensures
  that no markup in the result is evaluated.</p>
</blockquote></li>
<li><p><strong>next</strong>    : This action is present if <code>(cheerio|jQuery)( … ).next( … );</code> is
available.  The processor will jump to the first element of the
resulting selection.</p></li>
</ul></div></div></div><div class="segment"><div class="code folded"><div class="marker wrapper"><span class="c1"># ~require</span></div><div class="wrapper"><span class="p">{</span><span class="nx">Constants</span><span class="o">:</span><span class="p">{</span>
  <span class="nx">DEBUG</span><span class="p">,</span>
  <span class="nx">ATT_cache</span><span class="p">,</span>
  <span class="nx">PROP_cache</span><span class="p">,</span>
  <span class="nx">STRING_assigment</span><span class="p">,</span>
  <span class="nx">STRING_empty</span><span class="p">,</span>
  <span class="nx">STRING_seperator</span><span class="p">,</span>
  <span class="nx">STRING_zero</span>
<span class="p">}}</span>                    <span class="o">=</span> <span class="nx">require</span> <span class="s">&#39;../Core/Constants&#39;</span>

<span class="p">{</span><span class="nx">Document</span><span class="o">:</span><span class="p">{</span>
  <span class="nx">getAttribute</span><span class="p">,</span>
  <span class="nx">setAttribute</span><span class="p">,</span>
  <span class="nx">traverseElements</span><span class="p">,</span>
  <span class="nx">ownerDocument</span>
<span class="p">}}</span>                    <span class="o">=</span> <span class="nx">require</span> <span class="s">&#39;../Dom/Document&#39;</span>

<span class="p">{</span><span class="nx">Utility</span><span class="o">:</span><span class="p">{</span>
  <span class="nx">bind</span>
<span class="p">}}</span>                    <span class="o">=</span> <span class="nx">require</span> <span class="s">&#39;../Core/Utility&#39;</span></div></div></div><div class="segment"><div class="code folded"><div class="marker wrapper"><span class="c1"># ~export</span></div><div class="wrapper"><span class="nv">exports = </span><span class="nx">module</span><span class="o">?</span><span class="p">.</span><span class="nx">exports</span> <span class="o">?</span> <span class="k">this</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h1 id="processor">Processor</h1></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Class Process is in namespace <em>goatee.Action</em></span></p>

<hr />

<p>Internal class used by templates to maintain context.  This necessary to
process deep templates in Safari≤5 and mobile browsers having a relatively
shallow maximum recursion depth of 100.</p></div></div><div class="code"><div class="wrapper"><span class="nv">exports.Processor = </span><span class="k">class</span> <span class="nx">Processor</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public property document is of type <em>Document</em></span></p>

<hr />

<p>Caches the document of the template node, so we don't have to access it
through ownerDocument.</p></div></div><div class="code"><div class="wrapper">  <span class="nb">document</span><span class="o">:</span> <span class="kc">null</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public property options is of type <em>Object</em></span></p>

<hr />

<p>Holds this instance's options.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">options: </span><span class="kc">null</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Constructor</span></p>

<hr />

<p>Constructs the <code>Processor</code> instance.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>options is optional and must be an Object.</strong></p>

<ul><li><strong>options.document is optional and must be a Document.</strong></li></ul></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">constructor: </span><span class="nf">(@options) -&gt;</span>
    <span class="p">{</span><span class="nx">@</span><span class="nb">document</span><span class="p">}</span> <span class="o">=</span> <span class="nx">@options</span> <span class="k">if</span> <span class="o">not</span> <span class="nx">@</span><span class="nb">document</span><span class="o">?</span> <span class="o">and</span> <span class="nx">@options</span><span class="o">?</span> <span class="o">and</span> <span class="nx">@options</span><span class="p">.</span><span class="nb">document</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method run</span></p>

<hr />

<p>Runs the given function <code>fn</code> in our state machine.
It's informative to view the set of all function calls as a tree:
- nodes are states
- edges are state transitions, implemented as calls to the pending functions
  in the stack.
  - pre-order function calls are downward edges (recursion into call).
  - post-order function calls are upward edges (return from call).
- leaves are nodes which do not recurse.
We represent the call tree as an array of array of calls, indexed as
stack[depth][index].  Here [depth] indexes into the call stack, and [index]
indexes into the call queue at that depth.  We require a call-queue so that
a node may branch to more than one child (which will be called serially),
typically due to a loop structure.</p>

<p>Parameters:</p>

<ul>
<li><strong>fn must be a Function.</strong><br/>(The first function to run.)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">run: </span><span class="nf">(fn) -&gt;</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public property calls is of type <em>Array.<Array></em></span></p>

<p>A stack of queues of pre-order calls.  The inner arrays (constituent
queues) are structured as <code>[ arg2, arg1, method, arg2, arg1, method, ...]</code>
ie. a flattened array of methods with 2 arguments, in reverse order for
efficient push/pop.
The outer array is a stack of such queues.</p></div></div><div class="code"><div class="wrapper">    <span class="vi">@calls = </span><span class="nv">calls = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public property indices is of type <em>Array.<Number></em></span></p>

<p>The index into the queue for each depth.  Notice, an alternative would be
to maintain the queues in reverse order (popping off of the end) but the
repeated calls to <code>Array.pop()</code> consumed 90% of this function's execution
time.</p></div></div><div class="code"><div class="wrapper">    <span class="vi">@indices = </span><span class="nv">indices = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public property arrays is of type <em>Array.<Array></em></span></p>

<p>A pool of empty arrays.  Minimizes object allocation as performance and
memory benefit.</p></div></div><div class="code"><div class="wrapper">    <span class="vi">@arrays = </span><span class="nv">arrays = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>After initializing this state-machine execute the given start function.
It should have scope and arguments pre-bound.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">fn</span><span class="p">()</span>

    <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nx">calls</span><span class="p">.</span><span class="nx">length</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Determine the next queue.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">queue = </span><span class="nx">calls</span><span class="p">[</span><span class="nx">calls</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
      <span class="nv">index = </span><span class="nx">indices</span><span class="p">[</span><span class="nx">indices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the index is out of the queue's bound look for the next candidate</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">length</span>
        <span class="nx">@recycleArray</span> <span class="nx">calls</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
        <span class="nx">indices</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
        <span class="k">continue</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run the first function in the queue and record it's index.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">method = </span><span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">]</span>
      <span class="nv">arg1 = </span><span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">]</span>
      <span class="nv">arg2 = </span><span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">]</span>
      <span class="nx">indices</span><span class="p">[</span><span class="nx">indices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">index</span>
      <span class="nx">method</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span>
    <span class="k">return</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method push</span></p>

<hr />

<p>Pushes one or more functions onto the stack.  These will be run in sequence,
interspersed with any recursive calls that they make.
This method takes ownership of the given array!</p>

<p>Parameters:</p>

<ul>
<li><strong>args must be an Array.</strong><br/>(Array of method calls structured as <code>[ method, arg1, arg2, method, arg1, arg2, ... ]</code>)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">push: </span><span class="nf">(args) -&gt;</span>
    <span class="nx">@calls</span><span class="p">.</span><span class="nx">push</span> <span class="nx">args</span>
    <span class="nx">@indices</span><span class="p">.</span><span class="nx">push</span> <span class="mi">0</span>
    <span class="k">return</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method setup</span></p>

<hr />

<p>Prepares the template: pre-processes all template actions (formerly called
instructions).</p>

<p>Parameters:</p>

<ul>
<li><strong>template must be an Element.</strong></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">setup: </span><span class="nf">(template) -&gt;</span>
    <span class="k">unless</span> <span class="nx">@getCacheProperty</span><span class="p">(</span><span class="nx">template</span><span class="p">)</span><span class="o">?</span>
      <span class="nv">self = </span><span class="k">this</span>
      <span class="nx">Document</span><span class="p">.</span><span class="nx">traverseElements</span><span class="p">(</span><span class="nx">template</span><span class="p">,</span> <span class="nf">(node) -&gt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">prepare</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span>
    <span class="k">return</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-static doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Static public property actions is of type <em>Array.<Array></em></span></p>

<hr />

<p>A list of attributes we use to specify the processing actions (formerly
called instructions) and the functions used to parse their values.</p></div></div><div class="code"><div class="wrapper">  <span class="vi">@actions: </span><span class="p">[</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_select, jsEvalToFunction ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_display, jsEvalToFunction ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_values, jsEvalToValues ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_vars, jsEvalToValues ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_eval, jsEvalToExpressions ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_transclude, jsEvalToSelf ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_content, jsEvalToFunction ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_skip, jsEvalToFunction ]</span>
  <span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property _list is of type <em>Array</em></span></p>

<hr />

<p>A list for storing non-empty actions found on a node in prepare().  The
array is not an instance property, hence a kind of global, since it can be
reused.  This way there is no need to construct a new array object for each
invocation, which should increase the performance.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_list   = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property _list is of type <em>Object</em></span></p>

<hr />

<p>A map for storing temporary action values in <code>prepare()</code> so they don't have
to be retrieved twice, which should increase the performance.  The object is
not an instance property, hence a kind of global, since it can be reused.
This way there is no need to construct a new object for each invocation,
which should increase the performance.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_values = </span><span class="p">{}</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property _id is of type <em>Number</em></span></p>

<hr />

<p>A counter to generate cache ids.  These ids will be stored used to lookup
the pre-processed actions from the cache.  The id is stored with the element
to survive <code>cloneNode()</code> and thus cloned template nodes can share the same
cache entry.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_id = </span><span class="mi">0</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property _actions is of type <em>Object</em></span></p>

<hr />

<p>Map from cache <code>_id</code> to processed actions.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_actions = </span><span class="p">{}</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property _empty is of type <em>Object</em></span></p>

<hr />

<p>The neutral cache entry.  Used for all nodes that lack any actions. We still
set the id on those nodes so we can avoid looking again for all the other
actions that aren't there.  Remember, not only the processing of the action-
values is expensive and we thus want to cache it.  The access to the actions
on the Node in the first place is very expensive too.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_empty = </span><span class="nx">_actions</span><span class="p">[</span><span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_zero</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method prepare</span></p>

<hr />

<p>Prepares a single node: pre-processes all template attributes of the node
and if there are any, assigns an cache-identifier-attribute and stores the
pre-processed attributes under the identification in the <code>_actions</code>-cache.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong><br/>(The node to prepare for processing)</li>
</ul>

<p><strong>Returns an Object</strong><br/>(The cache entry, an object consisting of processed attributes or the <code>_empty</code> object, if the node has no relevant attributes)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">prepare: </span><span class="nf">(node) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the node already has a cache property, return it.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">cache = </span><span class="nx">@getCacheProperty</span> <span class="nx">node</span>
    <span class="k">return</span> <span class="nx">cache</span> <span class="k">if</span> <span class="nx">cache</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If it is not found, we always set a <code>PROP_cache</code>-property on the node.
Accessing the property is faster than executing <code>getAttribute()</code>.  If we
don't find the property on a node that was cloned, ie. by the <em>repeat</em>-
action (formerly <code>jstSelect_()</code>), we will fall back to check for the
attribute and set the property from cache.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the node has a cache-identifier, get the related cache object, set it
as a property and return it.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">id = </span><span class="nx">@getCacheIdentifier</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">id</span><span class="o">?</span>
      <span class="nv">cache = </span><span class="nx">@getCache</span> <span class="nx">id</span>
      <span class="k">if</span> <span class="nx">cache</span><span class="o">?</span>
        <span class="k">return</span> <span class="nx">@setCacheProperty</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Collect all action-attributes and their values</p></div></div><div class="code"><div class="wrapper">    <span class="nx">@collect</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">_list</span><span class="p">,</span> <span class="nx">_values</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If none found, mark this node to prevent further inspection, and return
an empty cache object.</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">@setEmpty</span> <span class="nx">node</span> <span class="k">if</span> <span class="nx">_list</span><span class="p">.</span><span class="nx">length</span> <span class="o">is</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Concatenates the action-attributes and their values in a way, that allows
comparison of these flattened string with other nodes' action attributes
(or possibly to reuse in other contexts, sometime in the future)</p></div></div><div class="code"><div class="wrapper">    <span class="nv">source = </span><span class="nx">@flatten</span> <span class="nx">_list</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we already have a cache entry corresponding to the flattened
attributes, annotate the node with it, and return it</p></div></div><div class="code"><div class="wrapper">    <span class="nv">id = </span><span class="nx">@getSourceIdentifier</span> <span class="nx">source</span>
    <span class="k">if</span> <span class="nx">id</span><span class="o">?</span>
      <span class="nv">cache = </span><span class="nx">@getCache</span> <span class="nx">id</span>
      <span class="k">if</span> <span class="nx">cache</span><span class="o">?</span>
        <span class="nx">@setCacheIdentifier</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">id</span>
        <span class="k">return</span> <span class="nx">@setCacheProperty</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">cache</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise, build a new cache object …</p></div></div><div class="code"><div class="wrapper">    <span class="nv">cache = </span><span class="nx">@createCache</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">_values</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>… and generate a new cache identifier.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">id    = </span><span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_empty</span> <span class="o">+</span> <span class="o">++</span><span class="nx">_id</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Now, cache the fresh entry.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">@setCache</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the <code>cloneNode()</code>-surviving cache identifier
for quicker access directly as a node attribute.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">@setCacheIdentifier</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the flattened cache entry for
quick rebuilds in the <code>_source</code>-cache.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">@setSourceIdentifier</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the fresh cache entry for quicker
access directly on the node and return it.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">@setCacheProperty</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method collect</span></p>

<hr />

<p>Collect actions from or for the given <code>node</code>.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>node must be an Element.</strong></p></li>
<li><p><strong>list must be an Array of Strings.</strong><br/>(Array to append the collected actions (formerly called instructions) to)</p></li>
<li><p><strong>values must be an Object of Strings.</strong><br/>(Object finally having the actions' names mapped to their raw values)</p></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">collect: </span><span class="nf">(node, list, values) -&gt;</span>
    <span class="k">for</span> <span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="k">in</span> <span class="nx">Processor</span><span class="p">.</span><span class="nx">actions</span>
      <span class="nv">value = </span><span class="nx">Document</span><span class="p">.</span><span class="nx">getAttribute</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">name</span>
      <span class="nx">values</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
      <span class="nx">list</span><span class="p">.</span><span class="nx">push</span> <span class="nx">@combine</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="k">if</span> <span class="nx">value</span><span class="o">?</span>
    <span class="k">return</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method combine</span></p>

<hr />

<p>Combines an action's name with its value, suitable for string comparisons.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>name must be a String.</strong></p></li>
<li><p><strong>value must be a String.</strong></p></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">combine: </span><span class="nf">(name, value) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alternative 1: Raw rule, using <code>|=|</code> as assignment. Obviously the fastest
implementation.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_empty</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_assigment</span> <span class="o">+</span> <span class="nx">value</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alternative 2: URL encoded rule, using <code>=</code> as assignment and encoding the
value as URI.
<code>
    Constants.STRING_empty + name + Constants.CHAR_equals + \
    encodeUriComponent(value)
</code></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alternative 3: CSS-like rule, using <code>:</code> as assignment and escaping the
double-quoted value.
<code>
    Constants.STRING_empty + name + Constants.CHAR_colon + \
    Constants.CHAR_doublequote + \
    (Constants.STRING_empty + value).replace('"','\\"') + \
    Constants.CHAR_doublequote
</code></p></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method flatten</span></p>

<hr />

<p>Concatenates a list of strings consisting of action-names combined with its
value, suitable for string comparisons, hence flatten.</p>

<p>Parameters:</p>

<ul>
<li><strong>list must be an Array of Strings.</strong><br/>(The list of actions-strings to concatenate)</li>
</ul>

<p><strong>Returns a String</strong><br/>(The concatenated list)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">flatten: </span><span class="nf">(list) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alternative 1: Raw rules, using <code>|||</code> as separator.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">list</span><span class="p">.</span><span class="nx">join</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_seperator</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alternative 2: URL encoded rules, using <code>&amp;</code> as separator.
<code>
    list.join Constants.CHAR_ampersand
</code></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alternative 3: CSS-like rules, using <code>;</code> as separator.
<code>
    list.join Constants.CHAR_semicolon
</code></p></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method createCache</span></p>

<hr />

<p>Create a new cache object.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>node must be an Element.</strong></p></li>
<li><p><strong>values must be an Object of Strings.</strong><br/>(Object having the actions' names mapped to their raw values)</p></li>
</ul>

<p><strong>Returns an Object of Functions or Strings</strong><br/>(Object having the actions' names mapped to their parsed values, skipping <code>undefined</code> and <code>null</code> values)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">createCache: </span><span class="nf">(node, values) -&gt;</span>
    <span class="nv">cache = </span><span class="p">{}</span>
    <span class="k">for</span> <span class="p">[</span><span class="nx">name</span><span class="p">,</span> <span class="nx">parse</span><span class="p">]</span> <span class="k">in</span> <span class="nx">Processor</span><span class="p">.</span><span class="nx">actions</span>
      <span class="nv">value = </span><span class="nx">values</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
      <span class="k">continue</span> <span class="k">unless</span> <span class="nx">value</span><span class="o">?</span>
      <span class="nx">cache</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parse</span> <span class="nx">value</span>
      <span class="k">if</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">DEBUG</span>
        <span class="nv">_debugCache = </span><span class="nx">cache</span><span class="p">.</span><span class="nx">_debugCache</span> <span class="o">?</span> <span class="nv">cache._debugCache = </span><span class="p">{}</span>
        <span class="nx">_debugCache</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
    <span class="nx">cache</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method getCacheProperty</span></p>

<hr />

<p>Get cached actions-property from given node.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong><br/>(The node to lookup the cache)</li>
</ul>

<p><strong>Returns an Object of Functions or Strings or an undefined</strong><br/>(An object having the actions' names mapped to their parsed values or <code>undefined</code> if no cache-property is available)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getCacheProperty: </span><span class="nf">(node) -&gt;</span>
    <span class="nx">node</span><span class="p">[</span><span class="nx">Constants</span><span class="p">.</span><span class="nx">PROP_cache</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method setCacheProperty</span></p>

<hr />

<p>Cache actions in a node-property.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>node must be an Element.</strong><br/>(The node to set the cache to.)</p></li>
<li><p><strong>actions must be an Object of Functions or Strings.</strong><br/>(An object having the actions' names mapped to their parsed values)</p></li>
</ul>

<p><strong>Returns an Object of Functions or Strings</strong><br/>(The cached actions)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">setCacheProperty: </span><span class="nf">(node, actions) -&gt;</span>
    <span class="nx">node</span><span class="p">[</span><span class="nx">Constants</span><span class="p">.</span><span class="nx">PROP_cache</span><span class="p">]</span> <span class="o">=</span> <span class="nx">actions</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method getCache</span></p>

<hr />

<p>Get cached actions from <code>_actions</code>-cache for given identifier.</p>

<p>Parameters:</p>

<ul>
<li><strong>id must be a String.</strong><br/>(Cache identifier to lookup)</li>
</ul>

<p><strong>Returns an Object of Functions or Strings or an undefined</strong><br/>(An object having the actions' names mapped to their parsed values or <code>undefined</code> if no cache-entry is available)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getCache: </span><span class="nf">(id) -&gt;</span>
    <span class="nx">_actions</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method setCache</span></p>

<hr />

<p>Cache actions in <code>_actions</code>-cache under given identifier.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>id must be a String.</strong><br/>(Identifier to store actions)</p></li>
<li><p><strong>actions must be an Object of Functions or Strings.</strong><br/>(An object having the actions' names mapped to their parsed values)</p></li>
</ul>

<p><strong>Returns an Object of Functions or Strings</strong><br/>(The cached actions)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">setCache: </span><span class="nf">(id, actions) -&gt;</span>
    <span class="nx">_actions</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="nx">actions</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method getCacheIdentifier</span></p>

<hr />

<p>Get cached identifier(-attribute) from given node.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong><br/>(The node to lookup the cache-identifier)</li>
</ul>

<p><strong>Returns a String or an undefined</strong><br/>(The cache-identifier or <code>undefined</code> if none is present)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getCacheIdentifier: </span><span class="nf">(node) -&gt;</span>
    <span class="nx">Document</span><span class="p">.</span><span class="nx">getAttribute</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">ATT_cache</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method setCacheIdentifier</span></p>

<hr />

<p>Store the cache identifier (as node-attribute).</p>

<p>Parameters:</p>

<ul>
<li><p><strong>node must be an Element.</strong><br/>(The node to store the identifier to)</p></li>
<li><p><strong>id must be a String.</strong><br/>(The identifier to store)</p></li>
</ul>

<p><strong>Returns a String</strong><br/>(The stored identifier)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">setCacheIdentifier: </span><span class="nf">(node, id) -&gt;</span>
    <span class="nx">Document</span><span class="p">.</span><span class="nx">setAttribute</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">ATT_cache</span><span class="p">,</span> <span class="nx">id</span>
    <span class="nx">id</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property _sources is of type <em>Object</em></span></p>

<hr />

<p>Map from source, a concatenated action string, to cache identifiers.  The
key is the concatenation of all <code>_actions</code> found on a node formatted as
<code>name1=value1&amp;name2=value2&amp;...</code>, in the order of the <code>Processor.actions</code>
array.  The value is the identifier of the cache-entry that can be used for
this node.  This allows the reuse of cache entries in cases when a cached
entry already exists for a given combination of attribute values.  For
example when two template-nodes share the same actions, like those created
by the <em>repeat</em>-action (formerly <em>jsselect</em>-instruction).</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_sources = </span><span class="p">{}</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method getSourceIdentifier</span></p>

<hr />

<p>Get cached identifier for given source.</p>

<p>Parameters:</p>

<ul>
<li><strong>source must be a String.</strong><br/>(A concatenated action string)</li>
</ul>

<p><strong>Returns a String or an undefined</strong><br/>(The cache-identifier or <code>undefined</code> if none is present)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getSourceIdentifier: </span><span class="nf">(source) -&gt;</span>
    <span class="nx">_sources</span><span class="p">[</span><span class="nx">source</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method setSourceIdentifier</span></p>

<hr />

<p>Cache identifier for given source.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>source must be a String.</strong><br/>(A concatenated action string)</p></li>
<li><p><strong>id must be a String.</strong><br/>(The cache-identifier to store to)</p></li>
</ul>

<p><strong>Returns a String</strong><br/>(The stored cache-identifier)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">setSourceIdentifier: </span><span class="nf">(source, id) -&gt;</span>
    <span class="nx">_sources</span><span class="p">[</span><span class="nx">source</span><span class="p">]</span> <span class="o">=</span> <span class="nx">id</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-public"><div class="wrapper"><p><span class='doc-section-header'>Public method setEmpty</span></p>

<hr />

<p>Mark all relevant caches as empty on given node.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong><br/>(The node to mark as beeing empty (=has no actions))</li>
</ul>

<p><strong>Returns an Object</strong><br/>(The <code>_empty</code> cache-object)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">setEmpty: </span><span class="nf">(node) -&gt;</span>
    <span class="nx">@setCacheIdentifier</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_zero</span>
    <span class="nx">@setCacheProperty</span> <span class="nx">_empty</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-static"><div class="wrapper"><p><span class='doc-section-header'>Static method create</span></p>

<hr />

<p>Create a new <code>Processor</code>-instance.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>options is optional and must be an Object.</strong><br/>(Options passed to <code>new Processor()</code>.)</p>

<ul><li><strong>options.document is optional and must be a Document.</strong></li></ul></li>
</ul>

<p><strong>Returns a goaate.Action.Processor</strong></p></div></div><div class="code"><div class="wrapper">  <span class="vi">@create: </span><span class="nf">(options) -&gt;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Processor</span> <span class="nx">options</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-static"><div class="wrapper"><p><span class='doc-section-header'>Static method process</span></p>

<hr />

<p>HTML template processor. Data values are bound to HTML templates using the
attributes defined in the <code>Processor.actions</code>-registry.  The template is
modified in place.  The values of those attributes are <del>JavaScript</del>
GoateeScript-expressions that are evaluated in the context of the data
object fragment.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>context must be a Context.</strong><br/>(Context created from the input data object.)</p></li>
<li><p><strong>template must be an Element.</strong><br/>(DOM node of the template to be processed in place. Afterwards it will still be a valid template that, if processed again with the same data, will remain unchanged.)</p></li>
<li><p><strong>options is optional and must be an Object.</strong><br/>(Options passed to <code>new Processor()</code>.)</p>

<ul><li><strong>options.document is optional and must be a Document.</strong></li></ul></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="vi">@process = </span><span class="nf">(context, template, options) -&gt;</span>

    <span class="nv">processor = </span><span class="nx">Processor</span><span class="p">.</span><span class="nx">create</span> <span class="nx">options</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the owner document</p></div></div><div class="code"><div class="wrapper">    <span class="nv">processor.document = </span><span class="nx">Document</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">(</span><span class="nx">template</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Traverse the template, emit actions and cache them</p></div></div><div class="code"><div class="wrapper">    <span class="nx">processor</span><span class="p">.</span><span class="nx">setup</span> <span class="nx">template</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Execute all actions</p></div></div><div class="code"><div class="wrapper">    <span class="nx">processor</span><span class="p">.</span><span class="nx">run</span> <span class="nx">Utility</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">processor</span><span class="p">,</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">outer</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">template</span><span class="p">)</span>
    <span class="k">return</span></div></div></div></div></body></html>