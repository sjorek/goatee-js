<!DOCTYPE html><html lang="en"><head><title>Action/Processor</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="Action/Processor"><meta name="groc-project-path" content="src/Action/Processor.coffee"><meta name="groc-github-url" content="https://github.com/sjorek/goatee-js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sjorek/goatee-js/blob/master/src/Action/Processor.coffee">src/Action/Processor.coffee</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>© Copyright 2013 Stephan Jorek <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;:&#x73;&#116;e&#112;&#104;&#x61;&#x6e;&#x2e;&#106;&#111;&#x72;&#x65;&#x6b;&#x40;&#x67;&#109;&#97;&#105;l&#46;&#99;&#111;&#x6d;">&#x73;&#116;e&#112;&#104;&#x61;&#x6e;&#x2e;&#106;&#111;&#x72;&#x65;&#x6b;&#x40;&#x67;&#109;&#97;&#105;l&#46;&#99;&#111;&#x6d;</a> <br />
© Copyright 2006 Google Inc. <a href="http://www.google.com">http://www.google.com</a></p>

<p>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>

<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>

<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h1 id="gaotee-evaluation">Gaotee Evaluation</h1>

<blockquote>
  <h2 id="overview">Overview</h2>
  
  <p>The processing instructions that define the results of Processor for a
  template are encoded as attributes in template HTML elements.  There are
  <del>eight such</del> special attributes: <em>jsselect</em>, <em>jsdisplay</em>, <em>jsskip</em>,
  <em>jscontent</em>, <em>jsvars</em>, <em>jsvalues</em>, <em>jseval</em>, and <em>transclude</em>.  Before you
  dive into the details of individual instructions, however, you should know a
  little bit about the namespace within which these instructions are processed.</p>
  
  <h2 id="processing-environment">Processing Environment</h2>
  
  <p>With the single exception of the <em>transclude</em> instruction, the values of all
  Template attributes will contain <del>javascript</del> expressions.  These
  will be evaluated in an environment that includes bindings from a variety of
  sources, and names defined by any of these sources can be referenced in
  attribute expressions as if they were variables:</p>
  
  <ul>
  <li><em>Context</em> data: All the properties of the <em>Context</em>'s data object are included
  in the processing environment.</li>
  <li><p>Explicitly declared variables: The <code>setVariable(name, value);</code> method of
  <em>Context</em> creates a new variable with the <code>name</code> in the processing
  environment if no such variable exists, assigning it the <code>value</code>. If the
  variable already exists, it will be reassigned the <code>value</code>.  Variables can
  also be created and assigned with the <em>jsvalues</em> instruction (see below).</p>
  
  <p>Note that variables defined in either of these ways are distinct from the
  <em>Context</em> data object. Calling <code>setVariable</code> will not alter the data wrapped
  by the <em>Context</em> instance.  This fact can have important consequences when
  template processing is traversing the hierarchy of the data object (through
  the use of the <em>jsselect</em> instruction, for example -- see below): no matter
  what portion of the data hierarchy has been selected for processing, variables
  created with <code>setVariable</code> will always be available for use in template
  processing instructions.</p></li>
  <li><p>Special variables: Jst also defines three special variables that can be used
  in processing instruction attributes:</p>
  
  <ul><li><code>this</code>: The keyword <code>this</code> in <em>Template</em> attribute expressions will
  evaluate to the element on which the attribute is defined.  In this
  respect <em>Template</em> attributes mirror event handler attributes like
  <code>onclick</code>.</li>
  <li><code>$index</code>: Array-valued data can result in a duplicate template node being
  created for each array element (see <em>jsselect</em>, below).  In this case the
  processing environment for each of those nodes includes <code>$index</code> variable,
  which will contain the array index of the element associated with the node.</li>
  <li><code>$this</code>: refers to the <em>Context</em> data object used in processing the current
  node.  So in the above example (TODO which example?!?) we could substitute
  <code>$this.end</code> for <code>end</code> without changing the meaning of the <em>jscontent</em>
  expression.  This may not seem like a very useful thing to do in this
  case, but there are other cases in which <code>$this</code> is necessary.  If the
  <em>Context</em> contains a value such as a string or a number rather than an
  object with named properties, there is no way to retrieve the value using
  object-property notation, and so we need <code>$this</code> to access the value.</li></ul></li>
  </ul>
  
  <p>So if you have the template</p>

<pre><code> &lt;div id="witha"&gt;
   &lt;div id="Hey"
        jscontent="this.parentNode.id +
                   this.id +
                   dataProperty +
                   $this.dataProperty +
                   declaredVar"
   &gt;&lt;!-- empty content to be replaced --&gt;&lt;/div&gt;
 &lt;/div&gt;
</code></pre>
  
  <p>and you process it with the statements</p>

<pre><code> var mydata = {dataProperty: 'Nonny'};
 var context = new JsEvalContext(mydata);
 context.setVariable('declaredVar', 'Ho');
 var template = document.getElementById('witha');
 jstProcess(context, template);
</code></pre>
  
  <p>then the document will display the string <code>withaHeyNonnyNonnyHo</code>. The values
  of <code>id</code> and <code>parentNode.id</code> are available as properties of the current node
  (accessible through the keyword <code>this</code>), the value of <code>dataProperty</code> is
  available (via both a naked reference and the special variable <code>$this</code>)
  because it is defined in the <em>Context</em>'s data object, and the value of
  <code>declaredVar</code> is available because it is defined in the <em>Context</em>'s variables.</p>
  
  <p>In the discussion of specific instruction attributes below, the phrase
  <em>“current node”</em> refers to the DOM element on which the attribute is defined.</p>
</blockquote>

<p>Goatee action attributes and event action names have been choosen
carefully in order to avoid naming collision with existing dom attributes,
events and properties.</p>

<p>Within a single element the actions are evaluated in the following order:</p>

<h2 id="outer-actions">Outer Actions</h2>

<p>Outer actions operate with and on tag and context, without touching any tag-
attributes. They implement aspects like automation, recursion or multiplicity.</p>

<ul>
<li><p><strong>process</strong> : This action initiates the processing automatically, after
the dom is ready. The algorithm uses the given <em>process</em>-data
as Context.  Additionally if “<a href="http://jquery.com">jQuery</a>” is
available and the given data is a string, <em>process</em> may be
either an global javascript variable reference, or if that fails
an url to an external json-file.  Changes to the process value,
will stop any process processing the same tag and start
re-processing.  The process will skip all nested tags which
itself contain a <em>process</em>-Attribute, hence any of those tags
will be processed automatically in the order of their
appearance.</p></li>
<li><p><strong>match</strong>   : If “<a href="http://jsonselect.org">json:select</a>” is available <em>match</em>
value is used as css3-like query onto the current context.
Therefore the context must be suiteable as 2nd argument of
<code>JSONSelect.match(…)</code>.</p></li>
<li><p><strong>render</strong>  : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">transclude</a>”.
If a <em>render</em> action is present no further actions are
processed.  Additionally if either “<a href="http://jquery.com">jQuery</a>”,
“<a href="http://matthewmueller.github.io/cheerio/">cheerio</a>”, or
“<a href="http://sizzlejs.com">Sizzle</a>” is available, <em>render</em> may be an
internal template-reference, like in:
<code>(cheerio||jQuery||Sizzle)( 'source #id .selector', this );</code>
or in the case of <em>jQuery</em> an external reference, like in:
<code>jQuery(this).load( 'http://source.url #element-id' );</code>


<blockquote>
  <p></p></p>
</blockquote>

<blockquote>
  <p>As <em>jsselect</em> does, the <em>transclude</em> instruction expands the
  structure of a template.  It does so by copying a structure
  from some other element in the document.  The value of the
  <em>transclude</em> attribute is interpreted as an element id literal
  rather than as a <del>javascript</del> expression. (This
  difference, by the way, is the reason for the absence of a
  “js” in its name.)</p>
  
  <p>If an element with the given id exists in the document, it is
  cloned and <strong>the clone replaces</strong> the node with the <em>transclude</em>
  attribute.  Template processing continues on the new element.
  If no element with the given id exists, the node with the
  <em>transclude</em> attribute is removed.  No further processing
  instruction attributes will be evaluated on a node if it has
  a <em>transclude</em> attribute.</p>
  
  <p>The <em>transclude</em> attribute allows for recursion, because a
  template can be transcluded into itself.  This feature can be
  handy when you want to display hierarchically structured data.
  If you have a hierarchically structured table of contents, for
  example, recursive <em>transclude</em> statements allow you represent
  the arbitrarily complex hierarchy with a simple template:</p>

<pre><code>&lt;script&gt;
   …
   // Hierarchical data:
   var tplData = {
     title: "JsTemplate",
     items: [ {
       title: "Using JsTemplate",
       items: [ {
         title: "The JsTemplate Module"
       }, {
         title: "Javascript Data"
       }, {
         title: "Template HTML"
       }, {
         title: "Processing Templates with Javascript Statements"
       } ]
     }, {
       title: "Template Processing Instructions",
       items: [ {
         title: "Processing Environment"
       }, {
         title: "Instruction Attributes",
         items: [ {
           title: "jscontent"
         }, {
           title: "jsselect"
         }, {
           title: "jsdisplay"
         }, {
           title: "transclude"
         }, {
           title: "jsvalues"
         }, {
           title: "jsskip"
         }, {
           title: "jseval"
         } ]
       } ]
     } ]
   };
   …
 &lt;/script&gt;
 &lt;div id="tpl"&gt;
   &lt;span jscontent="title"&gt;Outline heading&lt;/span&gt;
   &lt;ul jsdisplay="items.length"&gt;
     &lt;li jsselect="items"&gt;
       &lt;div transclude="tpl"&gt;&lt;!-- recursive tranclusion --&gt;&lt;/div&gt;
     &lt;/li&gt;
   &lt;/ul&gt;
 &lt;/div&gt;
</code></pre>
  
  <p>The recursion in this example terminates because eventually
  it reaches data objects that have no <code>items</code> property.  When
  the <em>jsselect</em> asks for <code>items</code> on one of these leaves, it
  evaluates to <code>null</code> and no further processing will be
  performed on that node.  Note also that when the node with a
  <em>transclude</em> attribute is replaced with the transcluded node
  in this example, the replacement node will not have a
  <em>transclude</em> attribute.</p>
  
  <p><em>“How to use JsTemplate”</em> described the use of the
  <code>jstGetTemplate</code> function to process a copy of a template
  rather than the original template.  Templates with recursive
  transcludes must be cloned in this way before processing.
  Because of the internal details of Jst processing, a template
  that contains a recursive reference to itself may be processed
  incorrectly if the original template is processed directly.
  The following (incomplete) javascript code will perform the
  required duplication for the above template:</p>

<pre><code>&lt;script&gt;
  var PEG_NAME = 'peg';
  var TEMPLATE_NAME = 'tpl';
  // Called by the body onload handler:
  function jsinit() {
    pegElement = domGetElementById(document, PEG_NAME);
    loadData(pegElement, TEMPLATE_NAME, tplData);
  }

  function loadData(peg, templateId, data) {
    // Get a copy of the template:
    var templateToProcess = jstGetTemplate(templateId);
    // Wrap our data in a context object:
    var processingContext = new JsEvalContext(data);
    // Process the template
    jstProcess(processingContext, templateToProcess);
    // Clear the element to which we'll attach the processed template:
    peg.innerHTML = '';
    // Attach the template:
    appendChild(peg, templateToProcess);
  }
&lt;/script&gt;
</code></pre>
</blockquote></li>
<li><p><strong>repeat</strong>  : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsselect</a>”.
If <em>repeat</em> is array-valued, remaining actions will be copied to
each new duplicate element created by the <em>repeat</em> and processed
when the further dom- traversal visits the new elements.


<blockquote>
  <p></p></p>
</blockquote>

<blockquote>
  <p>The primary function of JsTemplate is to create mappings
  between data structures and HTML representations of those data
  structures.  The <em>jsselect</em> attribute handles much of the work
  of defining this mapping by allowing you to associate a
  particular subtree of the data with a particular subtree of
  the template's DOM structure. When a template node with a
  <em>jsselect</em> attribute is processed, the value of the <em>jsselect</em>
  attribute is evaluated as a <del>javascript</del> expression
  in the current processing environment, as described above.
  If the result of this evaluation is not an array, the
  processor automatically creates a new <em>Context</em> object to wrap
  the result of the evaluation.  The processing environment for
  the current node now uses this new <em>Context</em> rather than the
  original <em>Context</em>.</p>
  
  <p>For example, imagine that you have the following data object
  (wrapped in a <em>Context</em> object constructed with
  <code>new Context(tplData);</code>):</p>

<pre><code>&lt;script&gt;
  …
  var tplData = {
    username:"Jane User",
    addresses:[ {
      location:"111 8th Av.",
      label:"NYC front door"
    }, {
      location:"76 9th Av.",
      label:"NYC back door"
    }, {
      location:"Mountain View",
      label:"Mothership"
    } ]
  };
  …
&lt;/script&gt;
</code></pre>
  
  <p>and you use this data in processing the template</p>

<pre><code>&lt;div id="tpl"&gt;
  &lt;span jsselect="username"
        jscontent="$this"
  &gt;&lt;!-- empty --&gt;&lt;/span&gt;'s Address Book
&lt;/div&gt;
</code></pre>
  
  <p>The <em>jsselect</em> attribute tells the processor to retrieve the
  username property of the data object, wrap this value
  (<em>“Jane User”</em>) in a new JsEvalContext, and use the new
  <em>Context</em> in processing the span element.  As a result,
  <code>$this</code> refers to <em>“Jane User”</em> in the context of the span,
  and the <em>jscontent</em> attribute evaluates to <code>"Jane User"</code>.</p>
  
  <p>Note that the <em>jsselect</em> has to be executed before the
  <em>jscontent</em> in order for this example to work.  In fact,
  <em>jsselect</em> is always evaluated before any other JsTemplate
  attributes (with the exception of <em>transclude</em>), and so the
  processing of all subsequent instructions for the same
  template element will take place in the new environment
  created by the jsselect (see <em>“Order of Evaluation”</em> below).</p>
  
  <p>What happens if you try to <em>jsselect</em> the array-valued
  addresses property of the data object?  If the result of
  evaluating a <em>jsselect</em> expression is an array, a duplicate
  of the current template node is created for each item in the
  array.  For each of these duplicate nodes a <code>new Context( … );</code>
  will be created to wrap the array item, and the processing
  environment for the duplicate node now uses this <em>Context</em>
  rather than the original.  In other words, <em>jsselect</em> operates
  as a sort of <code>foreach</code> statement in the case of arrays.  So
  you can expand your address book template to list addresses in
  your data object like so:</p>

<pre><code>&lt;div id="tpl"&gt;
  &lt;h1&gt;
    &lt;span jsselect="username"
          jscontent="$this"&gt;
      User de Fault
    &lt;/span&gt;'s Address Book
  &lt;/h1&gt;
  &lt;table cellpadding="5"&gt;
    &lt;tr&gt;
      &lt;th&gt;Location:&lt;/th&gt;
      &lt;th&gt;Label:&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr jsselect="addresses"&gt;
      &lt;td jscontent="location"&gt;&lt;!-- location --&gt;&lt;/td&gt;
      &lt;td jscontent="label"&gt;&lt;!-- label --&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
  
  <p>Processing this template with your <em>“Jane User”</em> address book
  data will produce a nice table with a row for each address.
  Since the execution of a <em>jsselect</em> instruction can change the
  number of children under a template node, we might worry that
  if we try to reprocess a template with new data the template
  will no longer have the structure we want.  JsTemplate manages
  this problem with a couple of tricks.  First, whenever a
  <em>jsselect</em> produces duplicate nodes as a result of an
  array-valued expression, the processor records an index for
  each node as an attribute of the element.  So if the duplicate
  nodes are reprocessed, the processor can tell that they
  started out as a single node and will reprocess them as if
  they are still the single node of the original template.
  Second, a template node is never entirely removed, even if a
  <em>jsselect</em> evaluates to <code>null</code>.  If it evaluates to <code>null</code> (or
  <code>undefined</code>), the current node will be hidden by setting
  <code>style="display:none"</code>, and no further processing will be
  performed on it.  But the node will still be present, and
  available for future reprocessing.</p>
</blockquote></li>
</ul>

<h2 id="inner-actions">Inner Actions</h2>

<p>Inner actions operate on tag element-attributes, -properties and -methods as
well as the context-data, -variables and -values.</p>

<ul>
<li><p><strong>appear</strong>  : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsdisplay</a>”.
The result determines if the node appears on page.  Therefore
the result is either booleanized and applied as css-display,
with <code>false</code> ~ <code>style="display: none"</code> and <code>true</code> ~
<code>style="display: block"</code>.  If the result matches a valid value
for css-display it is used directly in <code>display: …</code>.</p>

<blockquote>
  <p>The value of the <em>jsdisplay</em> attribute is evaluated as a
  <del>javascript</del> expression.  If the result is <code>false</code>,
  <code>0</code>, <code>""</code> or any other <del>javascript</del> value that is
  <code>true</code> when negated, the CSS display property of the current
  template node will be set to <em>“none”</em>, rendering it invisible
  <insert><em>without detaching it from the DOM</em><insert>, and no
  further processing will be done on this node or its children.
  This instruction is particularly useful for checking for empty
  content.  You might want to display an informative message if
  a user's address book is empty, for example, rather than just
  showing them an empty table.  The following template will
  accomplish this goal:</p>

<pre><code>&lt;div id="tpl"&gt;
  &lt;h1&gt;
    &lt;span jsselect="username"
          jscontent="$this"&gt;User de Fault&lt;/span&gt;'s Address Book
  &lt;/h1&gt;
  &lt;span jsdisplay="addresses.length==0"&gt;Address book is empty.&lt;/span&gt;
  &lt;table cellpadding="5" jsdisplay="addresses.length"&gt;
    &lt;tr&gt;
      &lt;th&gt;Location:&lt;/th&gt;
      &lt;th&gt;Label:&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr jsselect="addresses"&gt;
      &lt;td jscontent="location"&gt;&lt;!-- location --&gt;&lt;/td&gt;
      &lt;td jscontent="label"&gt;&lt;!-- label --&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
  
  <p>If the addresses array is empty, the user will see
  <em>“Address book is empty”</em>, but otherwise they will see the
  table of addresses as usual.</p>
</blockquote></li>
<li><p><strong>set</strong>     : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsvars</a>”.</p>

<blockquote>
  <p>This instruction is identical to <em>jsvalues</em>, except that all
  assignment targets are interpreted as variable names, whether
  or not they start with a dolar-sign (<em>“$”</em>) or a dot (<em>“.”</em>).
  That is, all assignment targets are interpreted as described
  in section 1 of the <em>jsvalues</em> section below.</p>
</blockquote></li>
<li><p><strong>alter</strong>   : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsvalues</a>”.</p>

<blockquote>
  <p>The <em>jsvalues</em> instruction provides a way of making
  assignments that alter the template processing environment.
  The template processor parses the value of the <em>jsvalues</em>
  attribute value as a semicolon-delimited list of name value
  pairs, with every name separated from its value by a colon.
  Every name represents a target for assignment.  Every value
  will be evaluated as a javascript expression and assigned to
  its associated target.  The nature of the target depends on
  the first character of the target name:</p>
  
  <ul><li>If the first character of the target name is "$", then the
  target name is interpreted as a reference to a variable in
  the current <code>JsEvalContext</code> processing environment.  This
  variable is created if it doesn't already exist, and
  assigned the result of evaluating its associated expression.
  It will then be available for subsequent template processing
  on this node and its descendants (including subsequent
  name-value pairs in the same <em>jsvalues</em> attribute). Note
  that the dollar sign is actually part of the variable name:
  if you create a variable with <code>jsvalues="$varname:varvalue"</code>,
  you must use <code>$varname</code> to retrieve the value.</li>
  <li>If the first character of the target name is ".", then the
  target name is interpreted as a reference to a javascript
  property of the current template node.  The property is
  created if it doesn't already exist, and is assigned the
  result of evaluating its associated expression. So the
  instruction <code>jsvalues=".id:'Joe';.style.fontSize:'30pt'"</code>
  would change the id of the current template node to "Joe"
  and change its font size to 30pt.</li>
  <li>If the first character of the target name is neither a dot
  nor a dollar sign, then the target name is interpreted as a
  reference to an XML attribute of the current template
  element.  In this case the instruction <code>jsvalues="name:value"</code>
  is equivalent to the javascript statement <code>this.setAttribute('name','value');</code>,
  where this refers to the current template node.  Just as in
  the case of a call to setAttribute, the value will be
  interpreted as a string (after javascript evaluation). So
  <code>jsvalues="sum:1+2"</code> is equivalent to <code>this.setAttribute('sum', '3');</code>.</li></ul>
  
  <p>The jsvalues instruction makes a handy bridge between the DOM
  and context data.  If you want a built-in event handler
  attribute like <code>onclick=" … "</code> to be able to access the
  currently selected portion of the <code>JsEvalContext</code> data, for
  example, you can use <em>jsvalues</em> to copy a reference to the
  data into an attribute of the current element, where it will
  be accessible in the <code>onclick=" … "</code> attribute via `this.
  The following example uses this approach to turn our outline
  into a collapsible outline:</p>

<pre><code>&lt;script&gt;
  // Function called by onclick to record state of
  // closedness and refresh the outline display
  function setClosed(jstdata, closedVal) {
    jstdata.closed = closedVal;
    loadData(PEG_ELEMENT, TEMPLATE_NAME, tplData);
  }
&lt;/script&gt;
&lt;div id="tpl"&gt;
  &lt;!-- Links to open and close outline sections: --&gt;
  &lt;a href="#"
     jsdisplay="closed"
     jsvalues=".jstdata:$this"
     onclick="setClosed(this.jstdata,0)"&gt;[Open]&lt;/a&gt;
  &lt;a href="#"
     jsdisplay="!closed &amp;&amp; items.length"
     jsvalues=".jstdata:$this"
     onclick="setClosed(this.jstdata,1)"&gt;[Close]&lt;/a&gt;
  &lt;span jscontent="title"&gt;Outline heading&lt;/span&gt;
  &lt;ul jsdisplay="items.length &amp;&amp; !closed"&gt;
    &lt;li jsselect="items"&gt;
      &lt;div transclude="tpl"&gt;
        &lt;!-- recursive tranclusion --&gt;
      &lt;/div&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</blockquote></li>
<li><p><strong>do</strong>      : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jseval</a>”.</p>

<blockquote>
  <p>The processor evaluates a jseval instruction as a javascript
  expression, or a series of javascript expressions separated by
  semicolons.  The jseval instruction thus allows you to invoke
  javascript functions during template processing, in the usual
  template processing environment, but without any of the
  predefined template processing effects of <em>jsselect</em>, <em>jsvalues</em>,
  <em>jsdisplay</em>, <em>jsskip</em>, or <em>jscontent</em>.  For example, with the
  addition of a jseval instruction to our outline title span,
  the processor can record a count of the total number of
  outline items with and without titles as it traverses the data
  hierarchy.</p>
  
  <p>The count information in this example is stored in the
  processing context with a call to setVariable, so that it
  will be available to template processing throughout the data
  hierarchy:</p>

<pre><code>var counter = { full: 0 };
processingContext.setVariable('$counter', counter);
</code></pre>
  
  <p>A jseval expression increments the count:</p>

<pre><code>&lt;span jscontent="title"
      jseval="title? $counter.full++: $counter.empty++"&gt;
  Outline heading
&lt;/span&gt;
</code></pre>
  
  <p>and then a separate template displays these counts at the
  bottom of the page:</p>

<pre><code>&lt;div id="titleCountTpl"&gt;
  &lt;p&gt;
    This outline has
    &lt;span jscontent="$counter.empty"&gt;0&lt;/span&gt;
    empty titles and
    &lt;span jscontent="$counter.full"&gt;0&lt;/span&gt;
    titles with content.
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
  
  <p>Note that when you close headings the counts change:
  <em>jsdisplay</em> is not only hiding the closed elements, but also
  aborting the processing of these elements, so that the
  <em>jseval</em> expressions on these elements are never evaluated.</p>
</blockquote></li>
<li><p><strong>skip</strong>    : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jsskip</a>”.</p>

<blockquote>
  <p>The value of the <em>jsskip</em> attribute is evaluated as a
  javascript expression.  If the result is any javascript value
  that evaluates to true in a boolean context, then the
  processor will not process the subtree under the current node.
  This instruction is useful for improving the efficiency of an
  application (to avoid unnecessarily processing deep trees, for
  example).</p>
  
  <p>The effect of a jsskip that evaluates to true is very similar
  to the result of a jsdisplay that evaluates to false.  In both
  cases, no processing will be performed on the node's children.
  However, <em>jsskip</em> will not prevent the current node from being
  displayed.</p>
</blockquote></li>
<li><p><strong>markup</strong>  : This action is present if <code>(cheerio|jQuery)( … ).html( … );</code> is
available.  This is nearly the same action as the <em>text</em>-action
below, except it allows markup to be embedded.
<strong>Use it with absolute caution! You have been warned !</strong></p></li>
<li><p><strong>text</strong>    : Formerly “<a href="http://code.google.com/p/google-jstemplate/wiki/TemplateProcessingInstructionReference">jscontent</a>”.
Uses <code>(cheerio|jQuery)( … ).text( … );</code> if available.  Otherwise
the given content will be assigned to <code>Node.innerHTML</code>.</p>

<blockquote>
  <p>This attribute is evaluated as a javascript expression in the
  current processing environment.  The string value of the
  result then becomes the text content of the current node.
  So the template:</p>

<pre><code>&lt;p id="tpl"&gt;
  Welcome &lt;span jscontent="$this"&gt;username&lt;/span&gt;
&lt;/p&gt;
</code></pre>
  
  <p>… when processed with the javascript statements:</p>

<pre><code>var tplData = "Joe User",
    input   = new JsEvalContext(tplData),
    output  = document.getElementById('tpl');
jstProcess(input, output);
</code></pre>
  
  <p>… will display <code>Welcome Joe User</code> in the browser.  Note the
  use of <code>$this</code> here: the <code>JsEvalContext</code> constructor is passed
  the string <code>"Joe User"</code>, and so this is the object to which
  <code>$this</code> refers.</p>
  
  <p>When the processor executes a <em>jscontent</em> instruction, a new
  text node object is created with the string value of the
  result as its nodeValue, and this new text node becomes the
  only child of the current node.  This implementation ensures
  that no markup in the result is evaluated.</p>
</blockquote></li>
<li><p><strong>next</strong>    : This action is present if <code>(cheerio|jQuery)( … ).next( … );</code> is
available.  The processor will jump to the first element of the
resulting selection.</p></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="p">{</span><span class="nx">Constants</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span> <span class="s">&#39;goatee/Core/Constants&#39;</span>
<span class="p">{</span><span class="nx">Utility</span><span class="p">}</span>   <span class="o">=</span> <span class="nx">require</span> <span class="s">&#39;goatee/Core/Utility&#39;</span>
<span class="p">{</span><span class="nx">Document</span><span class="p">}</span>  <span class="o">=</span> <span class="nx">require</span> <span class="s">&#39;goatee/Dom/Document&#39;</span>

<span class="nv">exports = </span><span class="nx">module</span><span class="o">?</span><span class="p">.</span><span class="nx">exports</span> <span class="o">?</span> <span class="k">this</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Class</span></p>

<h1 id="processor">Processor</h1>

<p>Internal class used by goatee-templates to maintain context.  This is
necessary to process deep templates in Safari≤5 which has a relatively
shallow maximum recursion depth of 100.</p></div></div><div class="code"><div class="wrapper"><span class="nv">exports.Processor = </span><span class="k">class</span> <span class="nx">Processor</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Document</em></span></p>

<p>#</p></div></div><div class="code"><div class="wrapper">  <span class="nb">document</span><span class="o">:</span> <span class="kc">null</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Object</em></span></p>

<p>#</p></div></div><div class="code"><div class="wrapper">  <span class="nv">options: </span><span class="kc">null</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#</p>

<p>Parameters:</p>

<ul>
<li><strong>options must be an Object.</strong></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">constructor: </span><span class="nf">(@options) -&gt;</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Document</em></span></p>

<p>#
Caches the document of the template node, so we don't have to
access it through ownerDocument.</p></div></div><div class="code"><div class="wrapper">    <span class="vi">@document = </span><span class="nx">@options</span><span class="p">.</span><span class="nb">document</span> <span class="o">\</span>
      <span class="k">if</span> <span class="o">not</span> <span class="nx">@</span><span class="nb">document</span><span class="o">?</span> <span class="o">and</span> <span class="nx">@options</span><span class="o">?</span> <span class="o">and</span> <span class="nx">@options</span><span class="p">.</span><span class="nb">document</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Runs the given function in our state machine.
It's informative to view the set of all function calls as a tree:
- nodes are states
- edges are state transitions, implemented as calls to the pending
  functions in the stack.
  - pre-order function calls are downward edges (recursion into call).
  - post-order function calls are upward edges (return from call).
- leaves are nodes which do not recurse.
We represent the call tree as an array of array of calls, indexed as
stack[depth][index].  Here [depth] indexes into the call stack, and
[index] indexes into the call queue at that depth.  We require a call
queue so that a node may branch to more than one child
(which will be called serially), typically due to a loop structure.</p>

<p>Parameters:</p>

<ul>
<li><strong>f must be a Function.</strong><br/>(The first function to run.)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">run: </span><span class="nf">(f) -&gt;</span>
    <span class="nv">self = </span><span class="k">this</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Array.<Array></em></span></p>

<p>#
A stack of queues of pre-order calls.
The inner arrays (constituent queues) are structured as
[ arg2, arg1, method, arg2, arg1, method, ...]
ie. a flattened array of methods with 2 arguments, in reverse order
for efficient push/pop.
The outer array is a stack of such queues.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">calls = self.calls = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Array.<Number></em></span></p>

<p>#
The index into the queue for each depth. NOTE: Alternative would
be to maintain the queues in reverse order (popping off of the
end) but the repeated calls to .pop() consumed 90% of this
function's execution time.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">indices = self.indices = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Array.<Array></em></span></p>

<p>#
A pool of empty arrays.  Minimizes object allocation for IE6's benefit.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">arrays = self.arrays = </span><span class="p">[]</span>

    <span class="nx">f</span><span class="p">()</span>
    <span class="k">while</span> <span class="nx">calls</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
      <span class="nv">queue = </span><span class="nx">calls</span><span class="p">[</span><span class="nx">calls</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
      <span class="nv">index = </span><span class="nx">indices</span><span class="p">[</span><span class="nx">indices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
      <span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">length</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">recycleArray</span> <span class="nx">calls</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
        <span class="nx">indices</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
        <span class="k">continue</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run the first function in the queue.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">method = </span><span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">]</span>
      <span class="nv">arg1 = </span><span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">]</span>
      <span class="nv">arg2 = </span><span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">]</span>
      <span class="nx">indices</span><span class="p">[</span><span class="nx">indices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">index</span>
      <span class="nx">method</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span>
    <span class="k">return</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Pushes one or more functions onto the stack.  These will be run in sequence,
interspersed with any recursive calls that they make.
This method takes ownership of the given array!</p>

<p>Parameters:</p>

<ul>
<li><strong>args must be an Array.</strong><br/>(Array of method calls structured as [ method, arg1, arg2, method, arg1, arg2, ... ])</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">push: </span><span class="nf">(args) -&gt;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">calls</span><span class="p">.</span><span class="nx">push</span> <span class="nx">args</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">push</span> <span class="mi">0</span>
    <span class="k">return</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Prepares the template: preprocesses all goatee-template actions.</p>

<p>Parameters:</p>

<ul>
<li><strong>template must be an Element.</strong></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">setup: </span><span class="nf">(template) -&gt;</span>
    <span class="k">unless</span> <span class="nx">@getCacheProperty</span><span class="p">(</span><span class="nx">template</span><span class="p">)</span><span class="o">?</span>
      <span class="nv">self = </span><span class="nx">@</span>
      <span class="nx">doc</span><span class="p">.</span><span class="nx">traverseElements</span><span class="p">(</span><span class="nx">template</span><span class="p">,</span> <span class="nf">(node) -&gt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">prepare</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span>
    <span class="k">return</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Array.<Array></em></span></p>

<p>#
A list of attributes we use to specify jst processing actions,
and the functions used to parse their values.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">actions: </span><span class="p">[</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_select, jsEvalToFunction ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_display, jsEvalToFunction ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_values, jsEvalToValues ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_vars, jsEvalToValues ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_eval, jsEvalToExpressions ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_transclude, jsEvalToSelf ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_content, jsEvalToFunction ],</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="c1">#    [ Constants.ATT_skip, jsEvalToFunction ]</span>
  <span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Array</em></span></p>

<p>#
A list for storing non-empty actions found on a node in prepare().
The array is global since it can be reused - this way there is no need to
construct a new array object for each invocation. (IE6 perf)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_list   = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Object</em></span></p>

<p>#
Map for storing temporary action values in prepare() so they don't have
to be retrieved twice. (IE6 perf)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_values = </span><span class="p">{}</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Number</em></span></p>

<p>#
Counter to generate cache ids. These ids will be stored used to lookup the
preprocessed actions from the cache.  The id is stored with the element
to survive cloneNode() and thus cloned template nodes can share the same
cache entry.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_id = </span><span class="mi">0</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Object</em></span></p>

<p>#
Map from cache id to processed actions.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_actions = </span><span class="p">{}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>#
The neutral cache entry. Used for all nodes that lack any actions.
We still set the id on those nodes so we can avoid looking again for all
the other actions that aren't there.  Remember: not only the
processing of the action-values is expensive and we thus want to
cache it.  The access to the actions on the Node in the first place
is very expensive too.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_empty = </span><span class="nx">_actions</span><span class="p">[</span><span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_zero</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Prepares a single node: preprocesses all template attributes of the
node, and if there are any, assigns a jsid attribute and stores the
preprocessed attributes under the jsid in the jstcache.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong></li>
</ul>

<p><strong>Returns an Object</strong><br/>(The jstcache entry. The processed jst attributes are properties of this object. If the node has no jst attributes, returns an object with no properties (the jscache_[0] entry).)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">prepare: </span><span class="nf">(node) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the node already has a cache property, return it.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">cache = </span><span class="nx">@getCacheProperty</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">cache</span> <span class="k">if</span> <span class="nx">cache</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If it is not found, we always set the PROP<em>jstcache property on the node.
Accessing the property is faster than executing getAttribute(). If we
don't find the property on a node that was cloned in jstSelect</em>(), we
will fall back to check for the attribute and set the property
from cache.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the node has an attribute indexing a cache object, set it as a property
and return it.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">id = </span><span class="nx">@getElementIdentifier</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">id</span><span class="o">?</span>
      <span class="nv">cache = </span><span class="nx">@getCache</span> <span class="nx">id</span>
      <span class="k">if</span> <span class="nx">cache</span><span class="o">?</span>
        <span class="k">return</span> <span class="nx">@setCacheProperty</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the node has an attribute indexing a cache object, set it as a property
and return it.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">@collect</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">_list</span><span class="p">,</span> <span class="nx">_values</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If none found, mark this node to prevent further inspection, and return
an empty cache object.</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">@setEmpty</span> <span class="nx">node</span> <span class="k">if</span> <span class="nx">_list</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nv">source = </span><span class="nx">@combine</span> <span class="nx">_list</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we already have a cache object corresponding to these attributes,
annotate the node with it, and return it</p></div></div><div class="code"><div class="wrapper">    <span class="nv">id = </span><span class="nx">@getSourceIdentifier</span> <span class="nx">source</span>
    <span class="k">if</span> <span class="nx">id</span><span class="o">?</span>
      <span class="nv">cache = </span><span class="nx">@getCache</span> <span class="nx">id</span>
      <span class="k">if</span> <span class="nx">cache</span><span class="o">?</span>
        <span class="nx">@setElementIdentifier</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">id</span>
        <span class="k">return</span> <span class="nx">@setCacheProperty</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">cache</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise, build a new cache object.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">cache = </span><span class="nx">@build</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">_values</span><span class="p">)</span>
    <span class="nv">id    = </span><span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_empty</span> <span class="o">+</span> <span class="o">++</span><span class="nx">_id</span>

    <span class="nx">@setCache</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span>
    <span class="nx">@setElementIdentifier</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
    <span class="nx">@setSourceIdentifier</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
    <span class="nx">@setCacheProperty</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Collect actions from node.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>node must be an Element.</strong></p></li>
<li><p><strong>Array must be an Array.</strong><br/>(to append collected intructions to)</p></li>
<li><p><strong>node must be an Element.</strong></p></li>
</ul>

<p><strong>Returns an Array of Arrays or Objects</strong><br/>(Array of action-list and its value-map)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">collect: </span><span class="nf">(node, list, values) -&gt;</span>
    <span class="k">for</span> <span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="k">in</span> <span class="nx">@actions</span>
      <span class="nv">value = </span><span class="nx">doc</span><span class="p">.</span><span class="nx">getAttribute</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">name</span>
      <span class="nx">values</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
      <span class="nx">list</span><span class="p">.</span><span class="nx">push</span> <span class="nx">@translate</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="k">if</span> <span class="nx">value</span><span class="o">?</span>
    <span class="k">return</span>

  <span class="nv">translate: </span><span class="nf">(name, value) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>raw rule (uses <code>|=|</code> as assignment)</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_empty</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="o">\</span>
      <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_assigment</span> <span class="o">+</span> <span class="nx">value</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>url encoded rule
uses <code>=</code> as assignment, encodes the value</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_empty</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="o">\</span>
      <span class="nx">Constants</span><span class="p">.</span><span class="nx">CHAR_equals</span> <span class="o">+</span> <span class="nx">encodeUriComponent</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>css-like formatted rule
uses <code>:</code> as assignment, escapes and double-quotes the value</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_empty</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="o">\</span>
      <span class="nx">Constants</span><span class="p">.</span><span class="nx">CHAR_colon</span> <span class="o">+</span> <span class="o">\</span>
      <span class="nx">Constants</span><span class="p">.</span><span class="nx">CHAR_doublequote</span> <span class="o">+</span> <span class="o">\</span>
      <span class="p">(</span><span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_empty</span> <span class="o">+</span> <span class="nx">value</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span><span class="p">,</span><span class="s">&#39;\\&quot;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="o">\</span>
      <span class="nx">Constants</span><span class="p">.</span><span class="nx">CHAR_doublequote</span>

  <span class="nv">combine: </span><span class="nf">(list) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>raw rule (uses <code>|||</code> as seperator)</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">join</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_seperator</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>url encoded rule (uses <code>&amp;</code> as seperator)</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">join</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">CHAR_ampersand</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>css-like formatted rule (uses <code>;</code> as seperator)</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">join</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">CHAR_semicolon</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Build a new cache object.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong></li>
</ul>

<p><strong>Returns an Array of Arrays</strong><br/>(Array of node's action-list and its value-map)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">build: </span><span class="nf">(node, values) -&gt;</span>
    <span class="nv">cache = </span><span class="p">{}</span>
    <span class="k">for</span> <span class="p">[</span><span class="nx">name</span><span class="p">,</span> <span class="nx">parse</span><span class="p">]</span> <span class="k">in</span> <span class="nx">@actions</span>
      <span class="nv">value = </span><span class="nx">values</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
      <span class="k">continue</span> <span class="k">unless</span> <span class="nx">value</span><span class="o">?</span>
      <span class="nx">cache</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parse</span> <span class="nx">value</span>
      <span class="k">if</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">DEBUG</span>
        <span class="nv">goatee = </span><span class="nx">cache</span><span class="p">.</span><span class="nx">goatee</span> <span class="o">?</span> <span class="nv">cache.goatee = </span><span class="p">{}</span>
        <span class="nx">goatee</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
    <span class="nx">cache</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Get cached actions-property from given node.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong></li>
</ul>

<p><strong>Returns an Object</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">getCacheProperty: </span><span class="nf">(node) -&gt;</span>
    <span class="nx">node</span><span class="p">[</span><span class="nx">Constants</span><span class="p">.</span><span class="nx">PROP_jstcache</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Cache actions in a node-property.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>node must be an Element.</strong></p></li>
<li><p><strong>actions must be an Object.</strong></p></li>
</ul>

<p><strong>Returns an Object</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">setCacheProperty: </span><span class="nf">(node, actions) -&gt;</span>
    <span class="nx">node</span><span class="p">[</span><span class="nx">Constants</span><span class="p">.</span><span class="nx">PROP_jstcache</span><span class="p">]</span> <span class="o">=</span> <span class="nx">actions</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Get cached actions-property for given id.</p>

<p>Parameters:</p>

<ul>
<li><strong>id must be a String.</strong></li>
</ul>

<p><strong>Returns an Object</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">getCache: </span><span class="nf">(id) -&gt;</span>
    <span class="nx">_actions</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Cache actions under given id.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>id must be a String.</strong></p></li>
<li><p><strong>actions must be an Object.</strong></p></li>
</ul>

<p><strong>Returns an Object</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">setCache: </span><span class="nf">(id, actions) -&gt;</span>
    <span class="nx">_actions</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="nx">actions</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Get cached identifier-attribute from given node.</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong></li>
</ul>

<p><strong>Returns a String</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">getElementIdentifier: </span><span class="nf">(node) -&gt;</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">getAttribute</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">ATT_jstcache</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Cache identifier as node-attribute.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>node must be an Element.</strong></p></li>
<li><p><strong>id must be a String.</strong></p></li>
</ul>

<p><strong>Returns a String</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">setElementIdentifier: </span><span class="nf">(node, id) -&gt;</span>
    <span class="nx">doc</span><span class="p">.</span><span class="nx">setAttribute</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">ATT_jstcache</span><span class="p">,</span> <span class="nx">id</span>
    <span class="nx">id</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> is of type <em>Object</em></span></p>

<p>#
Map from source, a concatenated action string, to cache id.  The key
is the concatenation of all <code>_actions</code> found on a node formatted as
"name1=value1&amp;name2=value2&amp;...", in the order defined by actions.
The value is the id of the cache-entry that can be used for this node.
This allows the reuse of cache entries in cases when a cached entry already
exists for a given combination of attribute values. (For example when two
template-nodes share the same actions.)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">_sources = </span><span class="p">{}</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Get cached identifier for given source.</p>

<p>Parameters:</p>

<ul>
<li><strong>source must be a String.</strong></li>
</ul>

<p><strong>Returns a String</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">getSourceIdentifier: </span><span class="nf">(source) -&gt;</span>
    <span class="nx">_sources</span><span class="p">[</span><span class="nx">source</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Cache identifier for given source.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>source must be a String.</strong></p></li>
<li><p><strong>id must be a String.</strong></p></li>
</ul>

<p><strong>Returns a String</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">setSourceIdentifier: </span><span class="nf">(source, id) -&gt;</span>
    <span class="nx">_sources</span><span class="p">[</span><span class="nx">source</span><span class="p">]</span> <span class="o">=</span> <span class="nx">id</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'></span></p>

<p>#
Mark all relevant caches as empty</p>

<p>Parameters:</p>

<ul>
<li><strong>node must be an Element.</strong></li>
</ul>

<p><strong>Returns an Object</strong></p></div></div><div class="code"><div class="wrapper">  <span class="nv">setEmpty: </span><span class="nf">(node) -&gt;</span>
    <span class="nx">@setElementIdentifier</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">Constants</span><span class="p">.</span><span class="nx">STRING_zero</span>
    <span class="nx">@setCacheProperty</span> <span class="nx">_empty</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-static"><div class="wrapper"><p><span class='doc-section-header'>Static method create</span></p>

<p>#</p>

<p>Parameters:</p>

<ul>
<li><strong>options must be an Object.</strong><br/>(Options passed to <code>new Processor()</code>.)</li>
</ul>

<p><strong>Returns a Processor</strong></p></div></div><div class="code"><div class="wrapper">  <span class="vi">@create: </span><span class="nf">(options) -&gt;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Processor</span> <span class="nx">options</span></div></div></div><div class="segment"><div class="comments doc-section doc-section-static"><div class="wrapper"><p><span class='doc-section-header'>Static method process</span></p>

<p>#
HTML template processor. Data values are bound to HTML templates
using the attributes transclude, jsselect, jsdisplay, jscontent,
jsvalues. The template is modifed in place. The values of those
attributes are JavaScript expressions that are evaluated in the
context of the data object fragment.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>context must be a Context.</strong><br/>(Context created from the input data object.)</p></li>
<li><p><strong>template must be an Element.</strong><br/>(DOM node of the template. This will be processed in place. After processing, it will still be a valid template that, if processed again with the same data, it will remain unchanged.)</p></li>
<li><p><strong>options must be an Object.</strong><br/>(Options passed to <code>Processor.create()</code>.)</p></li>
</ul>

<p><strong>Returns a void</strong></p></div></div><div class="code"><div class="wrapper">  <span class="vi">@process = </span><span class="nf">(context, template, options) -&gt;</span>

    <span class="nv">processor = </span><span class="nx">Processor</span><span class="p">.</span><span class="nx">create</span> <span class="nx">options</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the owner document</p></div></div><div class="code"><div class="wrapper">    <span class="nv">processor.document = </span><span class="nx">doc</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">(</span><span class="nx">template</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Traverse the template, emit actions and cache them</p></div></div><div class="code"><div class="wrapper">    <span class="nx">processor</span><span class="p">.</span><span class="nx">setup</span> <span class="nx">template</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Execute all actions</p></div></div><div class="code"><div class="wrapper">    <span class="nx">processor</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">Utility</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">processor</span><span class="p">,</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">outer</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">template</span><span class="p">))</span>
    <span class="k">return</span></div></div></div></div></body></html>