// Generated by CoffeeScript 1.6.3
/*
© Copyright 2013 Stephan Jorek <stephan.jorek@gmail.com>
© Copyright 2006 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.
*/


/*

Order of Evaluation
===================

Goatee instruction attributes and event actions within a single element are
evaluated in the following order:

Outer Processors
-------------------

• render        This action initiates the rendering automatically, after the
                dom is ready. The algorithm uses the given “render”-Data as
                Context. Additionally if “jQuery” is available and the given
                data is a string, “render” may be either an global javascript
                variable reference, or if that fails an url to an external json-
                file. Changes to the render value, will stop any process 
                rendering the same tag and start re-rendering. The rendering-
                process will skip all nested tags which it-self contain a
                “render”-Attribute, since any of those tags will be processed
                automatically in the order of their appearance.

• source        Formerly “transclude”. If a “source” action is present no
                further actions are processed. Additionally if either “Sizzle”, 
                “cheerio” or “jQuery” is available, “source” may be an internal
                template-reference, like in
                   `(jQuery||cheerio||Sizzle)( 'source #id .selector', this )`
                or if “jQuery” is available also an external reference, like in
                   `jQuery(this).load( 'http://source.url #element-id'” );`.

• select        Formerly “jsselect”. If “select” is array-valued, remaining
                actions will be copied to each new duplicate element created
                by the “select” and processed when the further dom-traversal
                visits the new elements. If “json:select” is available and
                “select” is a string, it is used as css3-like query onto the
                current context. Therefore the context must be suiteable as 2nd
                argument of “JSONSelect.match”. @see http://jsonselect.org

Inner Processors
-------------------

• show          Formerly “jsdisplay”.

• set           Formerly “jsvars”.

• alter         Formerly “jsvalues”.

• exec(ute)     Formerly “jseval”.

• stop          Formerly “jsskip”.

• markup        This action is present if `(cheerio|jQuery)(…).html()` is
                available.

• content       Formerly “jscontent”. Uses `(cheerio|jQuery)(…).text()` if
                available, otherwise Node.innerHTML will be assigned to given
                content.

• next          This action is present if `(cheerio|jQuery)(…).next()` is
                available.
*/


(function() {
  var JST_ATTRIBUTES, Processor, cache, constant, doc, root, utility;

  constant = require('goatee/Core/Constants');

  utility = require('goatee/Core/Utility');

  doc = require('goatee/Dom/Document');

  cache = require('goatee/Cache/Composite');

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Processor = Processor = (function() {
    Processor.prototype.cache = null;

    Processor.prototype.compiler = null;

    Processor.prototype.env = null;

    Processor.prototype.engine = null;

    function Processor(options) {
      this.cache = options.cache, this.compiler = options.compiler, this.env = options.env, this.engine = options.engine;
    }

    Processor.prototype.run_ = function(f) {
      var arg1, arg2, arrayPool, calls, index, indices, method, queue, self;
      self = this;
      calls = self.calls_ = [];
      indices = self.indices_ = [];
      arrayPool = self.arrayPool_ = [];
      f();
      while (calls.length > 0) {
        queue = calls[calls.length - 1];
        index = indices[indices.length - 1];
        if (index >= queue.length) {
          self.recycleArray_(calls.pop());
          indices.pop();
          continue;
        }
        method = queue[index++];
        arg1 = queue[index++];
        arg2 = queue[index++];
        indices[indices.length - 1] = index;
        method.call(self, arg1, arg2);
      }
    };

    Processor.prototype.push_ = function(args) {
      this.calls_.push(args);
      this.indices_.push(0);
    };

    return Processor;

  })();

  Processor.jstid_ = 0;

  Processor.jstcache_ = {};

  Processor.jstcache_[0] = {};

  Processor.jstcacheattributes_ = {};

  Processor.values_ = {};

  Processor.list_ = [];

  Processor.prepareTemplate_ = function(template) {
    if (template[constant.PROP_jstcache]) {
      return doc.traverseElements(template, (function(node) {
        return Processor.prepareNode_(node);
      }));
    }
  };

  JST_ATTRIBUTES = [];

  Processor.prepareNode_ = function(node) {
    var attstring, jstcache, jstid, list, name, parse, value, values, _i, _j, _len, _len1, _ref;
    if (this.cache.has(node)) {
      return this.cache.get(node);
    }
    if (node[constant.PROP_jstcache] != null) {
      return node[constant.PROP_jstcache];
    }
    jstid = doc.getAttribute(node, constant.ATT_jstcache);
    if (jstid != null) {
      return node[constant.PROP_jstcache] = Processor.jstcache_[jstid];
    }
    values = Processor.values_;
    list = Processor.list_;
    utility.clearArray(list);
    for (_i = 0, _len = JST_ATTRIBUTES.length; _i < _len; _i++) {
      name = JST_ATTRIBUTES[_i][0];
      value = doc.getAttribute(node, attr[0]);
      values[name] = value;
      if (value != null) {
        list.push(name + "=" + value);
      }
    }
    if (list.length === 0) {
      doc.setAttribute(node, constant.ATT_jstcache, constant.STRING_zero);
      return node[constant.PROP_jstcache] = Processor.jstcache_[0];
    }
    attstring = list.join(constant.CHAR_ampersand);
    if (jstid = Processor.jstcacheattributes_[attstring]) {
      doc.setAttribute(node, constant.ATT_jstcache, jstid);
      return node[constant.PROP_jstcache] = Processor.jstcache_[jstid];
    }
    jstcache = {};
    for (_j = 0, _len1 = JST_ATTRIBUTES.length; _j < _len1; _j++) {
      _ref = JST_ATTRIBUTES[_j], name = _ref[0], parse = _ref[1];
      value = values[name];
      if (value == null) {
        continue;
      }
      jstcache[name] = parse(value);
      if (constant.DEBUG) {
        jstcache.jstAttributeValues = jstcache.jstAttributeValues || {};
        jstcache.jstAttributeValues[name] = value;
      }
    }
    jstid = constant.STRING_empty + ++Processor.jstid_;
    doc.setAttribute(node, constant.ATT_jstcache, jstid);
    Processor.jstcache_[jstid] = jstcache;
    Processor.jstcacheattributes_[attstring] = jstid;
    return node[constant.PROP_jstcache] = jstcache;
  };

}).call(this);
