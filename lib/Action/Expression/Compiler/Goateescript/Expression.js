// Generated by CoffeeScript 1.6.3
/*
Â© Copyright 2013 Stephan Jorek <stephan.jorek@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.
*/


(function() {
  var Expression, Stack, global, root, _ref,
    __slice = [].slice;

  global = (function() {
    return this;
  })();

  Stack = require('./Stack').Stack;

  root = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : this;

  root.Expression = Expression = (function() {
    var _booleanize, _errors, _evaluate, _execute, _global, _isArray, _isExpression, _isFunction, _isNumber, _isProperty, _operations, _operator, _process, _scope, _stack, _stringify, _toString, _variables;

    _stack = void 0;

    _scope = null;

    _errors = null;

    _global = null;

    _variables = null;

    _operations = null;

    _toString = Object.prototype.toString;

    _isArray = Array.isArray != null ? Array.isArray : function(obj) {
      return _toString.call(obj) === '[object Array]';
    };

    _isNumber = function(obj) {
      return (obj === +obj) || _toString.call(obj) === '[object Number]';
    };

    _isFunction = function(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    };

    _isProperty = function() {
      var p;
      p = _stack.parent();
      return (p != null) && p.operator.name === '.' && p.parameters[1] === _stack.current();
    };

    _isExpression = function(obj) {
      return _isFunction(obj != null ? obj.evaluate : void 0);
    };

    _execute = function(context, expression) {
      var e, result;
      if (!_isExpression(expression)) {
        return expression;
      }
      _stack.push(context, expression);
      try {
        result = _process(context, expression);
      } catch (_error) {
        e = _error;
        (_errors != null ? _errors : _errors = []).push(e.message);
      } finally {
        _stack.pop();
      }
      return result;
    };

    Expression.parse = (function() {
      var Parser, cache;
      cache = {};
      Parser = null;
      return function(code) {
        var expression;
        if (cache.hasOwnProperty(code)) {
          return cache[code];
        }
        if (Parser == null) {
          Parser = require('./Parser');
        }
        expression = Parser.parse(code);
        return cache[code] = cache['' + expression] = expression;
      };
    })();

    Expression.evaluate = _evaluate = function(context, expression, variables, stack, scope) {
      var isGlobalScope, result;
      if (context == null) {
        context = {};
      }
      if (!_isExpression(expression)) {
        return expression;
      }
      isGlobalScope = _stack === void 0;
      if (isGlobalScope) {
        _stack = new Stack(context, variables, stack, scope);
        _scope = _stack.scope;
        _errors = null;
        _global = _stack.global;
        _variables = _stack.variables;
        _evaluate = _execute;
      }
      result = _execute(context, expression);
      if (isGlobalScope) {
        _stack.destructor();
        _stack = void 0;
        _scope = null;
        _global = null;
        _variables = null;
        _evaluate = Expression.evaluate;
      }
      if (_errors != null) {
        console.log(_errors);
      }
      return result;
    };

    _process = function(context, expression) {
      var left, leftValue, operator, parameters, right, rightValue, value, values, _i, _j, _len, _len1;
      operator = expression.operator, parameters = expression.parameters;
      if (operator.chain) {
        if (parameters.length !== 2) {
          throw new Error("chain only supports 2 parameters");
        }
        left = parameters[0], right = parameters[1];
        context = _execute(context, left);
        if (left.vector) {
          values = [];
          for (_i = 0, _len = context.length; _i < _len; _i++) {
            leftValue = context[_i];
            rightValue = _execute(leftValue, right);
            value = operator.evaluate.call(leftValue, leftValue, rightValue);
            if (right.vector) {
              if (!_isArray(value)) {
                throw new Error("vector operation did not return an array as expected: " + (JSON.stringify(operator)));
              }
              values.push.apply(values, value);
            } else if (value != null) {
              values.push(value);
            }
          }
          return values;
        }
        rightValue = _execute(context, right);
        return operator.evaluate.call(context, context, rightValue);
      }
      if (operator.rawParameters) {
        return operator.evaluate.apply(context, parameters);
      }
      values = [];
      for (_j = 0, _len1 = parameters.length; _j < _len1; _j++) {
        rightValue = parameters[_j];
        values.push(_execute(context, rightValue));
      }
      return operator.evaluate.apply(context, values);
    };

    Expression.booleanize = _booleanize = function(value) {
      var item, _i, _len;
      if (_isArray(value)) {
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          item = value[_i];
          if (_booleanize(item)) {
            return true;
          }
        }
        return false;
      }
      return Boolean(value);
    };

    Expression.stringify = _stringify = function(value) {
      var format, operator, parameter, parameters, _i, _len;
      if (!_isExpression(value)) {
        return JSON.stringify(value);
      }
      operator = value.operator, parameters = value.parameters;
      format = operator.format;
      if (format != null) {
        return format.apply(this, parameters);
      } else if (parameters.length === 2) {
        return "(" + (_stringify(parameters[0])) + operator + (_stringify(parameters[1])) + ")";
      } else {
        format = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          format.push(_stringify(parameter));
        }
        return format.join(' ');
      }
    };

    Expression.operations = _operations = {
      '=': {
        evaluate: function(a, b) {
          return _variables[a] = b;
        }
      },
      '-=': {},
      '+=': {},
      '*=': {},
      '/=': {},
      '%=': {},
      '^=': {},
      '>>>=': {},
      '>>=': {},
      '<<=': {},
      '&=': {},
      '|=': {},
      '.': {
        chain: true,
        evaluate: function(a, b) {
          if (a !== _global && _isFunction(b)) {
            return b.bind(a);
          } else {
            return b;
          }
        }
      },
      '+': {
        constant: true,
        evaluate: function(a, b) {
          return a + b;
        }
      },
      '-': {
        constant: true,
        evaluate: function(a, b) {
          return a - b;
        }
      },
      '*': {
        constant: true,
        evaluate: function(a, b) {
          return a * b;
        }
      },
      '!': {
        constant: true,
        evaluate: function(a) {
          return !a;
        }
      },
      '~': {
        constant: true,
        evaluate: function(a) {
          return ~a;
        }
      },
      '/': {
        constant: true,
        evaluate: function(a, b) {
          return a / b;
        }
      },
      '%': {
        constant: true,
        evaluate: function(a, b) {
          return a % b;
        }
      },
      '^': {
        constant: true,
        evaluate: function(a, b) {
          return a ^ b;
        }
      },
      '>>>': {
        constant: true,
        evaluate: function(a, b) {
          return a >>> b;
        }
      },
      '>>': {
        constant: true,
        evaluate: function(a, b) {
          return a >> b;
        }
      },
      '<<': {
        constant: true,
        evaluate: function(a, b) {
          return a << b;
        }
      },
      '&': {
        constant: true,
        evaluate: function(a, b) {
          return a & b;
        }
      },
      '|': {
        constant: true,
        evaluate: function(a, b) {
          return a | b;
        }
      },
      '&&': {
        rawParameters: true,
        constant: true,
        evaluate: function(a, b) {
          a = _execute(this, a);
          if (!a) {
            return a;
          }
          b = _execute(this, b);
          return b;
        }
      },
      '||': {
        rawParameters: true,
        constant: true,
        evaluate: function(a, b) {
          a = _execute(this, a);
          if (a) {
            return a;
          }
          b = _execute(this, b);
          return b;
        }
      },
      '<': {
        constant: true,
        vector: false,
        evaluate: function(a, b) {
          return a < b;
        }
      },
      '>': {
        constant: true,
        vector: false,
        evaluate: function(a, b) {
          return a > b;
        }
      },
      '<=': {
        constant: true,
        vector: false,
        evaluate: function(a, b) {
          return a <= b;
        }
      },
      '>=': {
        constant: true,
        vector: false,
        evaluate: function(a, b) {
          return a >= b;
        }
      },
      '==': {
        constant: true,
        vector: false,
        expandParameters: false,
        evaluate: function(a, b) {
          return a == b;
        }
      },
      '!=': {
        constant: true,
        vector: false,
        expandParameters: false,
        evaluate: function(a, b) {
          return a != b;
        }
      },
      '===': {
        constant: true,
        vector: false,
        evaluate: function(a, b) {
          return a === b;
        }
      },
      '!==': {
        constant: true,
        vector: false,
        evaluate: function(a, b) {
          return a !== b;
        }
      },
      '?:': {
        constant: true,
        rawParameters: true,
        vector: false,
        format: function(a, b, c) {
          return "(" + (_stringify(a)) + "?" + (_stringify(b)) + ":" + (_stringify(c)) + ")";
        },
        evaluate: function(a, b, c) {
          a = _execute(this, a);
          return _execute(this, _booleanize(a) ? b : c);
        }
      },
      '()': {
        vector: false,
        format: function() {
          var args, func;
          func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return func + '(' + args.join(',') + ')';
        },
        evaluate: function() {
          var args, func;
          func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (func == null) {
            throw new Error("Missing argument to call.");
          }
          if (!_isFunction(func)) {
            throw new Error("Given argument is not callable.");
          }
          return func.apply(this, args);
        }
      },
      '[]': {
        chain: false,
        vector: false,
        format: function(a, b) {
          return "" + a + "[" + b + "]";
        },
        evaluate: function(a, b) {
          var index;
          if (_isNumber(b) && b < 0) {
            index = (a.length != null ? a.length : 0) + b;
          } else {
            index = b;
          }
          return a[index];
        }
      },
      '{}': {
        chain: true,
        vector: false,
        format: function(a, b) {
          return "" + a + "{" + b + "}";
        },
        evaluate: function(a, b) {
          if (_booleanize(b)) {
            return a;
          } else {
            return void 0;
          }
        }
      },
      context: {
        format: function(a) {
          return a;
        },
        vector: false,
        evaluate: function(a) {
          return {
            '$': _global,
            '@': _variables
          }[a];
        }
      },
      reference: {
        format: function(a) {
          return a;
        },
        vector: false,
        evaluate: function(a) {
          var context, ref, value, _i;
          ref = _isProperty();
          value = this[a];
          if (ref) {
            if (this.hasOwnProperty(a)) {
              return value;
            }
          } else {
            if (_variables.hasOwnProperty(a)) {
              return _variables[a];
            }
            for (_i = _scope.length - 1; _i >= 0; _i += -1) {
              context = _scope[_i];
              if (context.hasOwnProperty(a)) {
                return context[a];
              }
            }
          }
          return value;
        }
      },
      primitive: {
        constant: true,
        vector: false,
        format: function(a) {
          return JSON.stringify(a);
        },
        evaluate: function(a) {
          return a;
        }
      },
      block: {
        format: function() {
          var statements;
          statements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return "{" + (statements.join(';')) + "}";
        },
        evaluate: function() {
          return arguments[arguments.length - 1];
        }
      },
      "if": {
        rawParameters: true,
        format: function(a, b, c) {
          if (c != null) {
            return "if (" + a + ") " + b + " else " + c;
          } else {
            return "if (" + a + ") " + b;
          }
        },
        evaluate: function(a, b, c) {
          if (_booleanize(_execute(this, a))) {
            return _execute(this, b);
          } else if (c != null) {
            return _execute(this, c);
          } else {
            return void 0;
          }
        }
      },
      array: {
        format: function() {
          var elements;
          elements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return "[" + (elements.join(',')) + "]";
        },
        evaluate: function() {
          var elements;
          elements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return elements;
        }
      },
      object: {
        format: function() {
          var buffer, i, k, _i, _len;
          buffer = [];
          for (i = _i = 0, _len = arguments.length; _i < _len; i = _i += 2) {
            k = arguments[i];
            buffer.push("" + k + ":" + arguments[i + 1]);
          }
          return "{" + (buffer.join(',')) + "}";
        },
        evaluate: function() {
          var i, k, object, _i, _len;
          object = {};
          for (i = _i = 0, _len = arguments.length; _i < _len; i = _i += 2) {
            k = arguments[i];
            object[k] = arguments[i + 1];
          }
          return object;
        }
      }
    };

    (function() {
      var key, value, _assign, _evaluateRef, _formatRef;
      _evaluateRef = _operations.reference.evaluate;
      _formatRef = _operations.reference.format;
      _assign = _operations['='].evaluate;
      for (key in _operations) {
        value = _operations[key];
        value.name = key;
        value.toString = (function() {
          var k;
          k = key;
          return function() {
            return k;
          };
        })();
        value.toJSON = function() {
          return this.name;
        };
        if (key[key.length - 1] === "=") {
          if (value.format == null) {
            value.format = (function() {
              var k;
              k = key;
              return function(a, b) {
                return "(" + (_formatRef(a)) + k + (_stringify(b)) + ")";
              };
            })();
          }
          if (value.evaluate == null) {
            value.evaluate = (function() {
              var _op;
              _op = _operations[key.substring(0, key.length - 1)].evaluate;
              return function(a, b) {
                return _assign(a, _op(_evaluateRef(a), b));
              };
            })();
          }
        }
      }
    })();

    Expression.operator = _operator = function(name) {
      var op;
      if ((op = _operations[name]) != null) {
        return op;
      }
      throw new Error("operation not found: " + name);
    };

    function Expression(op, params) {
      var param, _i, _j, _len, _len1;
      if (params == null) {
        params = [];
      }
      this.operator = _operator(op);
      this.parameters = params;
      this.constant = this.operator.constant === true;
      if (this.constant) {
        for (_i = 0, _len = params.length; _i < _len; _i++) {
          param = params[_i];
          if (_isExpression(param) && !param.constant) {
            this.constant = false;
            break;
          }
        }
      }
      this.vector = this.operator.vector;
      if (this.vector === void 0) {
        this.vector = false;
        for (_j = 0, _len1 = params.length; _j < _len1; _j++) {
          param = params[_j];
          if (_isExpression(param) && param.vector) {
            this.vector = true;
            break;
          }
        }
      }
      if (this.constant && this.operator.name !== 'primitive') {
        return new Expression('primitive', [this.evaluate(global)]);
      }
      return;
    }

    Expression.prototype.toString = function() {
      if (this.text !== void 0) {
        return this.text;
      }
      return this.text = _stringify(this);
    };

    Expression.prototype.toJSON = function() {
      return {
        op: this.operator.name,
        parameters: this.parameters
      };
    };

    Expression.prototype.evaluate = function(context) {
      return _evaluate(context, this);
    };

    return Expression;

  })();

}).call(this);

/*
//@ sourceMappingURL=Expression.map
*/
