// Generated by CoffeeScript 1.6.3
/*
© Copyright 2013 Stephan Jorek <stephan.jorek@gmail.com>
© Copyright 2006 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.
*/


/*

Gaotee Evaluation
===================

Goatee action attributes and event action names have been choosen
carefully in order to avoid naming collision with existing dom attributes,
events and properties.

Within a single element they are evaluated in the following order:

Outer Actions
-------------------

Outer actions operate with and on tag and context, without touching any tag-
attributes. They implement aspects like automation, recursion or multiplicity.

• process       This action initiates the processing automatically, after
                the dom is ready. The algorithm uses the given “process”-data as
                Context. Additionally if “jQuery” is available and the given
                data is a string, “process” may be either an global javascript
                variable reference, or if that fails an url to an external json-
                file. Changes to the process value, will stop any process
                processing the same tag and start re-processing. The processing-
                process will skip all nested tags which it-self contain a
                “process”-Attribute, hence any of those tags will be processed
                automatically in the order of their appearance.

• match         If “json:select” is available and “match” value is used as
                css3-like query onto the current context. Therefore the context
                must be suiteable as 2nd argument of “JSONSelect.match”.
                @see http://jsonselect.org

• render        Formerly “transclude”. If a “render” action is present no
                further actions are processed. Additionally if either
                “Sizzle”, “cheerio” or “jQuery” is available, “render” may be
                an internal template-reference, like in
                   `(jQuery||cheerio||Sizzle)( 'source #id .selector', this )`
                or in the case of “jQuery” an external reference, like in
                   `jQuery(this).load( 'http://source.url #element-id'” );`.

• repeat        Formerly “jsselect”.  If “repeat” is array-valued, remaining
                actions will be copied to each new duplicate element
                created by the “repeat” and processed when the further dom
                traversal visits the new elements.

Inner Actions
-------------------

Inner actions operate on tag element-attributes, -properties and -methods as
well as the context-data, -variables and -values.

• appear        Formerly “jsdisplay”.

• set           Formerly “jsvars”.

• alter         Formerly “jsvalues”.

• do            Formerly “jseval”.

• skip          Formerly “jsskip”.

• markup        This action is present if `(cheerio|jQuery)(…).html()` is
                available.

• text          Formerly “jscontent”. Uses `(cheerio|jQuery)(…).text()` if
                available, otherwise Node.innerHTML will be assigned to given
                content.

• next          This action is present if `(cheerio|jQuery)(…).next()` is
                available.
*/


(function() {
  var Constants, Document, Processor, Utility, root, _ref;

  Constants = require('goatee/Core/Constants').Constants;

  Utility = require('goatee/Core/Utility').Utility;

  Document = require('goatee/Dom/Document').Document;

  root = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : this;

  root.Processor = Processor = (function() {
    var _actions, _empty, _id, _list, _sources, _values;

    Processor.prototype.document = null;

    Processor.prototype.options = null;

    function Processor(options) {
      this.options = options;
      if ((this.document == null) && (this.options != null) && (this.options.document != null)) {
        this.document = this.options.document;
      }
    }

    Processor.prototype.run = function(f) {
      var arg1, arg2, arrays, calls, index, indices, method, queue, self;
      self = this;
      calls = self.calls = [];
      indices = self.indices = [];
      arrays = self.arrays = [];
      f();
      while (calls.length > 0) {
        queue = calls[calls.length - 1];
        index = indices[indices.length - 1];
        if (index >= queue.length) {
          self.recycleArray(calls.pop());
          indices.pop();
          continue;
        }
        method = queue[index++];
        arg1 = queue[index++];
        arg2 = queue[index++];
        indices[indices.length - 1] = index;
        method.call(self, arg1, arg2);
      }
    };

    Processor.prototype.push = function(args) {
      this.calls.push(args);
      this.indices.push(0);
    };

    Processor.prototype.setup = function(template) {
      var self;
      if (this.getCacheProperty(template) == null) {
        self = this;
        doc.traverseElements(template, function(node) {
          return self.prepare(node);
        });
      }
    };

    Processor.prototype.actions = [];

    _list = [];

    _values = {};

    _id = 0;

    _actions = {};

    _empty = _actions[Constants.STRING_zero] = {};

    Processor.prototype.prepare = function(node) {
      var cache, id, source;
      cache = this.getCacheProperty(node);
      if (cache != null) {
        return cache;
      }
      id = this.getElementIdentifier(node);
      if (id != null) {
        cache = this.getCache(id);
        if (cache != null) {
          return this.setCacheProperty(node, cache);
        }
      }
      this.collect(node, _list, _values);
      if (_list.length === 0) {
        return this.setEmpty(node);
      }
      source = this.combine(_list);
      id = this.getSourceIdentifier(source);
      if (id != null) {
        cache = this.getCache(id);
        if (cache != null) {
          this.setElementIdentifier(node, id);
          return this.setCacheProperty(node, cache);
        }
      }
      cache = this.build(node, _values);
      id = Constants.STRING_empty + ++_id;
      this.setCache(id, cache);
      this.setElementIdentifier(node, id);
      this.setSourceIdentifier(source, id);
      return this.setCacheProperty(node, cache);
    };

    Processor.prototype.collect = function(node, list, values) {
      var name, value, _i, _len, _ref1;
      _ref1 = this.actions;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        name = _ref1[_i][0];
        value = doc.getAttribute(node, name);
        values[name] = value;
        if (value != null) {
          list.push(this.translate(name, value));
        }
      }
    };

    Processor.prototype.translate = function(name, value) {
      return Constants.STRING_empty + name + Constants.STRING_assigment + value;
      return Constants.STRING_empty + name + Constants.CHAR_equals + encodeUriComponent(value);
      return Constants.STRING_empty + name + Constants.CHAR_colon + Constants.CHAR_doublequote + (Constants.STRING_empty + value).replace('"', '\\"') + Constants.CHAR_doublequote;
    };

    Processor.prototype.combine = function(list) {
      return list.join(Constants.STRING_seperator);
      return list.join(Constants.CHAR_ampersand);
      return list.join(Constants.CHAR_semicolon);
    };

    Processor.prototype.build = function(node, values) {
      var cache, goatee, name, parse, value, _i, _len, _ref1, _ref2, _ref3;
      cache = {};
      _ref1 = this.actions;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], name = _ref2[0], parse = _ref2[1];
        value = values[name];
        if (value == null) {
          continue;
        }
        cache[name] = parse(value);
        if (Constants.DEBUG) {
          goatee = (_ref3 = cache.goatee) != null ? _ref3 : cache.goatee = {};
          goatee[name] = value;
        }
      }
      return cache;
    };

    Processor.prototype.getCacheProperty = function(node) {
      return node[Constants.PROP_jstcache];
    };

    Processor.prototype.setCacheProperty = function(node, actions) {
      return node[Constants.PROP_jstcache] = actions;
    };

    Processor.prototype.getCache = function(id) {
      return _actions[id];
    };

    Processor.prototype.setCache = function(id, actions) {
      return _actions[id] = actions;
    };

    Processor.prototype.getElementIdentifier = function(node) {
      return doc.getAttribute(node, Constants.ATT_jstcache);
    };

    Processor.prototype.setElementIdentifier = function(node, id) {
      doc.setAttribute(node, Constants.ATT_jstcache, id);
      return id;
    };

    _sources = {};

    Processor.prototype.getSourceIdentifier = function(source) {
      return _sources[source];
    };

    Processor.prototype.setSourceIdentifier = function(source, id) {
      return _sources[source] = id;
    };

    Processor.prototype.setEmpty = function(node) {
      this.setElementIdentifier(node, Constants.STRING_zero);
      return this.setCacheProperty(_empty);
    };

    return Processor;

  })();

  Processor.create = function(options) {
    return new Processor(options);
  };

  Processor.process = function(context, template, options) {
    var processor;
    processor = Processor.create(options);
    processor.document = doc.ownerDocument(template);
    processor.setup(template);
    processor.run(Utility.bind(processor, processor.outer, context, template));
  };

}).call(this);

/*
//@ sourceMappingURL=Processor.map
*/
